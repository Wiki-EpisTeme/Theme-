<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="css curso/style de css.css">
	<link rel="stylesheet" href="css curso/figura2-2.css">
	<title>-CSS3.</title>
</head>
<body>
	<header>
		<section class="cabeza">
			<a href="https://wiki-episteme.github.io/Theme-/"><h1>CSS3, Curso completo.</h1></a>
		</section>
	</header>

	<section class="caja-indice">
		<div class="caja-1">
			<nav  class="contenido-del-indice">
				<h3 id="0" class="elemento0">Indice</h3>

				<!--  Primer capitulo de css3  -->

				<li ><a class="elemento0"href="curso de css.html#1" >| Estilos CSS y modelos de caja</a></li><br>
				<li><a href="curso de css.html#1" class="elemento">- CSS y HTM</a></li><br>
				<li><a href="curso de css.html#2" class="elemento">- Estilos y estructura</a></li>
				<li><a href="curso de css.html#3" class="elemento1">+ Elementos Block</a></li>
				<li><a href="curso de css.html#4" class="elemento1">+ Modelos de caja</a></li><br>
				<li><a href="curso de css.html#5" class="elemento">- Conceptos básicos sobre estilo</a></li><br>
				<li><a href="curso de css.html#6" class="elemento1">+ Estilos en línea</a></li>
				<li><a href="curso de css.html#7" class="elemento1">+ Estilos embebidos</a></li>
				<li><a href="curso de css.html#8" class="elemento1">+ Archivos externos</a></li>
				<li><a href="curso de css.html#9" class="elemento1">+ Referencias</a></li>
				<li><a href="curso de css.html#10" class="elemento1">+ Referenciando con palabra clave</a></li>
				<li><a href="curso de css.html#11" class="elemento1">+ Referenciando con el atributo id </a></li>
				<li><a href="curso de css.html#12" class="elemento1">+ Referenciando con el atributo class</a></li>
				<li><a href="curso de css.html#13" class="elemento1">+ Referenciando con cualquier atributo </a></li>
				<li><a href="++++++++++++++++++++" class="elemento1">+ Referenciando con pseudo clases</a></li>
				<li><a href="curso de css.html#14" class="elemento1">+ Nuevos selectores</a></li><br><br>

				<!--segundo capitulo de aprendiendo css3-->

				<li><a class="elemento0"href="curso de css.html#15">| Aplicando CSS a nuestra plantilla</a></li><br><br>
				<li><a href="curso de css.html#16" class="elemento">- Modelo de caja tradicional</a></li><br>
				<li><a href="curso de css.html#17" class="elemento1">+ Plantilla </a></li>
				<li><a href="curso de css.html#18" class="elemento1">+ Selector universal *</a></li>
				<li><a href="curso de css.html#19" class="elemento1">+ Nueva jerarquía para cabeceras</a></li>
				<li><a href="curso de css.html#20" class="elemento1">+ Declarando nuevos elementos HTML5</a></li>
				<li><a href="curso de css.html#21" class="elemento1">+ Centrando el cuerpo</a></li>
				<li><a href="curso de css.html#22" class="elemento1">+ Creando la caja principal</a></li>
				<li><a href="curso de css.html#23" class="elemento1">+ La cabecera</a></li>
				<li><a href="curso de css.html#24" class="elemento1">+ Barra de navegación</a></li>
				<li><a href="curso de css.html#25" class="elemento1">+ Section y aside</a></li>
				<li><a href="curso de css.html#26" class="elemento1">+ Footer</a></li>
				<li><a href="curso de css.html#27" class="elemento1">+ Últimos toques</a></li>
				<li><a href="curso de css.html#28" class="elemento1">+ Box-sizing</a></li><br>
				<li><a href="curso de css.html#29" class="elemento">- Referencia rápida</a></li>
				<li><a href="curso de css.html#30" class="elemento1">+ Selector de atributo y pseudo clases</a></li>
				<li><a href="curso de css.html#31" class="elemento1">+ Selectores</a></li><br>

				<!-- tercer capitulo de aprendiendo css3-->

				<li class="elemento0"><a href="curso de css.html#1" ></a>| Propiedades CSS</li><br>
				<li><a href="curso de css.html#32" class="elemento">- Las nuevas regla</a></li>
				<li><a href="curso de css.html#33" class="elemento1">+ CSS3 se vuelve loc</a></li>
				<li><a href="curso de css.html#34" class="elemento1">+ Plantilla</a></li>
				<li><a href="curso de css.html#35" class="elemento1">+ Border-radius</a></li>
				<li><a href="curso de css.html#36" class="elemento1">+ Box-shadow</a></li>
				<li><a href="curso de css.html#37" class="elemento1">+ Text-shadow </a></li>
				<li><a href="curso de css.html#38" class="elemento1">+ @font-face</a></li>
				<li><a href="curso de css.html#39" class="elemento1">+ Gradiente lineal </a></li>
				<li><a href="curso de css.html#40" class="elemento1">+ Gradiente radial </a></li>
				<li><a href="curso de css.html#41" class="elemento1">+ RGBA</a></li>
				<li><a href="curso de css.html#42" class="elemento1">+ HSLA</a></li>
				<li><a href="curso de css.html#43" class="elemento1">+ Outline</a></li>
				<li><a href="curso de css.html#44" class="elemento1">+ Border-image</a></li>
				<li><a href="curso de css.html#45" class="elemento1">+ Transform y transition </a></li>
				<li><a href="curso de css.html#46" class="elemento1">+ Transform: scale</a></li>
				<li><a href="curso de css.html#47" class="elemento1">+ Transform: rotate </a></li>
				<li><a href="curso de css.html#48" class="elemento1">+ Transform: skew </a></li>
				<li><a href="curso de css.html#49" class="elemento1">+ Transform: translate </a></li>
				<li><a href="curso de css.html#50" class="elemento1">+ Transformando todo al mismo tiempo.</a></li>
				<li><a href="curso de css.html#51" class="elemento1">+ Transformaciones dinámicas</a></li>
				<li><a href="curso de css.html#52" class="elemento1">+ Transiciones</a></li><br>
				<li><a href="curso de css.html#52" class="elemento">- Referencia rápida</a></li>
			</nav>
		</div>

			<!--
				aqui la otra linea de Herramientas de css3

			-->
	
		<div class="caja-2">
			<nav>
				<h3 class="elemento0">| Herramientas y Documentacion</h3>
				<nav>
					<li><a href="sub-selectores.html" class="elemento">+ Selectores</a></li>
					<li><a href="sub-elementos de css3.html" class="elemento">+ Pseudo clases</a></li>
					<li><a href="sub-elementos de css3.html" class="elemento">+ Fonts & Text</a></li>
					<li><a href="sub-elementos de css3.html" class="elemento">+ Box Madel</a></li>
					<li><a href="sub-elementos de css3.html" class="elemento">+ Colors</a></li>
					<li><a href="sub-elementos de css3.html" class="elemento">+ Posiciones</a></li>

					
					



					
				</nav>
			</nav>
		</div>
	</section>



<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>


	<article id="1">
		<h2>CSS y HTML</h2>
		<p>
			Como aclaramos anteriormente, la nueva especificación de HTML (HTML5) no describe
			solo los nuevos elementos HTML o el lenguaje mismo. La web demanda diseño y
			funcionalidad, no solo organización estructural o definición de secciones. En este nuevo
			paradigma, HTML se presenta junto con CSS y Javascript como un único instrumento
			integrado.
		</p><br>
		<p>
			La función de cada tecnología ya ha sido explicada en capítulos previos, así como los
			nuevos elementos HTML responsables de la estructura del documento. Ahora es
			momento de analizar CSS, su relevancia dentro de esta unión estratégica y su influencia
			sobre la presentación de documentos HTML.
		</p><br>
		<p>
			Oficialmente CSS nada tiene que ver con HTML5. CSS no es parte de la especificación y
			nunca lo fue. Este lenguaje es, de hecho, un complemento desarrollado para superar las
			limitaciones y reducir la complejidad de HTML. Al comienzo, atributos dentro de las
			etiquetas HTML proveían estilos esenciales para cada elemento, pero a medida que el
			lenguaje evolucionó, la escritura de códigos se volvió más compleja y HTML por sí mismo
			no pudo más satisfacer las demandas de diseñadores. En consecuencia, CSS pronto fue
			adoptado como la forma de separar la estructura de la presentación. Desde entonces, CSS
			ha crecido y ganado importancia, pero siempre desarrollado en paralelo, enfocado en las
			necesidades de los diseñadores y apartado del proceso de evolución de HTML.
		</p><br>
		<p>
			La versión 3 de CSS sigue el mismo camino, pero esta vez con un mayor compromiso. La
			especificación de HTML5 fue desarrollada considerando CSS a cargo del diseño. Debido a
			esta consideración, la integración entre HTML y CSS es ahora vital para el desarrollo web y
			esta es la razón por la que cada vez que mencionamos HTML5 también estamos haciendo
			referencia a CSS3, aunque oficialmente se trate de dos tecnologías completamente
			separadas.
		</p><br>
		<p>
			En este momento las nuevas características incorporadas en CSS3 están siendo
			implementadas e incluidas junto al resto de la especificación en navegadores compatibles
			con HTML5. En este capítulo, vamos a estudiar conceptos básicos de CSS y las nuevas
			técnicas de CSS3 ya disponibles para presentación y estructuración. También
			aprenderemos cómo utilizar los nuevos selectores y pseudo clases que hacen más fácil la
			selección e identificación de elementos HTML.
		</p><br>
		<p>
			<b>Conceptos básicos:</b> CSS es un lenguaje que trabaja junto con HTML para proveer
			estilos visuales a los elementos del documento, como tamaño, color, fondo,
			bordes, etc...
		</p><br>
		<p>
			<b>IMPORTANTE:</b> En este momento las nuevas incorporaciones de CSS3 están siendo
			implementadas en las últimas versiones de los navegadores más populares, pero
			algunas de ellas se encuentran aún en estado experimental. Por esta razón, estos
			nuevos estilos deberán ser precedidos por prefijos tales como –moz- o -webkit-
			para ser efectivamente interpretados. Analizaremos este importante asunto más
			adelante.
		</p><br>
	</article><hr><br><br><br><br><br>

	<article id="2">
		<h2>Estilos y estructura.</h2>
		<p>
			A pesar de que cada navegador garantiza estilos por defecto para cada uno de los
			elementos HTML, estos estilos no necesariamente satisfacen los requerimientos de cada
			diseñador. Normalmente se encuentran muy distanciados de lo que queremos para
			nuestros sitios webs. Diseñadores y desarrolladores a menudo deben aplicar sus propios
			estilos para obtener la organización y el efecto visual que realmente desean.
		</p><br>
		<p>
			<b>IMPORTANTE:</b> En esta parte del capítulo vamos a revisar estilos CSS y explicar
			algunas técnicas básicas para definir la estructura de un documento. Si usted ya
			se encuentra familiarizado con estos conceptos, siéntase libre de obviar las
			partes que ya conoce
		</p><br>
	</article><hr><br><br><br><br><br>
	<article id="3">


		<h2>Elementos block</h2>
		<p>
			Con respecto a la estructura, básicamente cada navegador ordena los elementos por
			defecto de acuerdo a su tipo: block (bloque) o inline (en línea). Esta clasificación está
			asociada con la forma en que los elementos son mostrados en pantalla.
		</p><br>
	</article>

		<div class="lista">
			<ul>
				<li>
					<b>Elementos block</b> son posicionados uno sobre otro hacia abajo en la página.
				</li><br>
				<li>
					<b>Elementos inline</b> son posicionados lado a lado, uno al lado del otro en la misma
					línea, sin ningún salto de línea a menos que ya no haya más espacio horizontal
					para ubicarlos.
				</li>
			</ul>
		</div><br>
	<article>
		<p>
			Casi todos los elementos estructurales en nuestros documentos serán tratados por los
			navegadores como elementos block por defecto. Esto significa que cada elemento <b>HTML</b>
			que representa una parte de la organización visual (por ejemplo,<b><|section></b>, <b><|nav></b>,
			<b><|header></b>, <b><|footer></b>, <b><|div></b>) será posicionado debajo del anterior.
		</p><br>
		<p>
			En el curso de <b>HTML</b> creamos un documento <b>HTML</b> con la intención de reproducir un sitio web
			tradicional. El diseño incluyó barras horizontales y dos columnas en el medio. Debido a la
			forma en que los navegadores muestran estos elementos por defecto, el resultado en la pantalla está muy lejos de nuestras expectativas. Tan pronto como el archivo <b>HTML</b> con el
			código del Listado 1-18, es abierto en el navegador, la posición errónea en la
			pantalla de las dos columnas definidas por los elementos <b><|section></b> y <b><|aside></b> es
			claramente visible. Una columna está debajo de la otra en lugar de estar a su lado, como
			correspondería. Cada bloque (block) es mostrado por defecto tan ancho como sea posible, tan
			alto como la información que contiene y uno sobre otro, como se muestra en la Figura 2-1
		</p><br>
	

		<div class="lista">
			<img src="media/figura curso de css 1.png" alt="" width="500px" >
			<figure class="figura"><b>Figura 1-1.</b>  Representación visual de una página web mostrada con estilos por defecto.</figure>
		</div><hr><br><br><br><br><br>
	</article>
	<article id="4">
		<h2>Modelos de caja</h2>
		<p>
			Para aprender cómo podemos crear nuestra propia organización de los elementos en
			pantalla, debemos primero entender cómo los navegadores procesan el código HTML. Los
			navegadores consideran cada elemento HTML como una caja. Una página web es en
			realidad un grupo de cajas ordenadas siguiendo ciertas reglas. Estas reglas son
			establecidas por estilos provistos por los navegadores o por los diseñadores usando CSS.
		</p><br>
		<p>
			CSS tiene un set predeterminado de propiedades destinados a sobrescribir los estilos
			provistos por navegadores y obtener la organización deseada. Estas propiedades no son
			específicas, tienen que ser combinadas para formar reglas que luego serán usadas para
			agrupar cajas y obtener la correcta disposición en pantalla. La combinación de estas reglas
			 es normalmente llamada modelo o sistema de disposición. Todas estas reglas aplicadas
			juntas constituyen lo que se llama un modelo de caja.
		</p><br>
		<p>
			Existe solo un modelo de caja que es considerado estándar estos días, y muchos otros que aún se encuentran en estado experimental. El modelo válido y ampliamente adoptado es el llamado Modelo de Caja Tradicional, el cual ha sido usado desde la primera versión de CSS.
		</p><br>
		<p>
			Aunque este modelo ha probado ser efectivo, algunos modelos experimentales
			intentan superar sus deficiencias, pero la falta de consenso sobre el reemplazo más
			adecuado aún mantiene a este viejo modelo en vigencia y la mayoría de los sitios webs
			programados en HTML5 lo continúan utilizando.
		</p>
	</article><hr><br><br><br><br><br>

	<article id="5">
		<h2>Conceptos básicos sobre estilos</h2>
		<p>
			Antes de comenzar a insertar reglas CSS en nuestro archivo de estilos y aplicar un modelo
			de caja, debemos revisar los conceptos básicos sobre estilos CSS que van a ser utilizados
			en el resto del libro.
		</p><br>
		<p>
			Aplicar estilos a los elementos HTML cambia la forma en que estos son presentados en
			pantalla. Como explicamos anteriormente, los navegadores proveen estilos por defecto
			que en la mayoría de los casos no son suficientes para satisfacer las necesidades de los
			diseñadores. Para cambiar esto, podemos sobrescribir estos estilos con los nuestros
			usando diferentes técnicas.
		</p><br>
		<p>
			<b>Conceptos básicos:</b> En este libro encontrará solo una introducción breve a los
			estilos CSS. Solo mencionamos las técnicas y propiedades que necesita conocer
			para entender los temas y códigos estudiados en próximos capítulos. Si considera
			que no tiene la suficiente experiencia en CSS y necesita mayor información visite
			nuestro sitio web y siga los enlaces correspondientes a este capítulo.
		</p><br>
		<p>
			<b>Hágalo usted mismo:</b> Dentro de un archivo de texto vacío, copie cada código
			HTML estudiado en los siguientes listados y abra el archivo en su navegador para
			comprobar su funcionamiento. Tenga en cuenta que el archivo debe tener la
			extensión.html para ser abierto y procesado correctamente
		</p><br>
	</article><hr><br><br><br><br><br>
	
	<article id="6">
		<h2>Estilos en línea</h2>
		<p>
			Una de las técnicas más simples para incorporar estilos CSS a un documento HTML es la de
			asignar los estilos dentro de las etiquetas por medio del atributo <b>style.</b>
		</p><br>
		<p>
			El Listado 2-1 muestra un documento  <b>HTML</b> simple que contiene el elemento <"p>
			modificado por el atributo <b>style</b>  con el valor <b><i>font-size: 20px.</i> </b>Este estilo cambia el
			tamaño por defecto del texto dentro del elemento <"p> a un nuevo tamaño de <b>20 pixeles.</b>
		</p><br>

		<div class="lista">
			<pre>
				<code>
					!DOCTYPE html>
					html lang="es">
					head>
						title>Este es el título del documento/title>
					/head>
					body>
						p style=”font-size: 20px”>Mi texto/p>
					/body>
					/html>
				</code>
			</pre>
		</div>
		<div class="figura"><b>Listado 2-1.</b> Estilos CSS dentro de etiquetas HTML</div>
		<p>
			Usar la técnica demostrada anteriormente es una buena manera de probar estilos y
			obtener una vista rápida de sus efectos, pero no es recomendado para aplicar estilos a
			todo el documento. La razón es simple: cuando usamos esta técnica, debemos escribir y
			repetir cada estilo en cada uno de los elementos que queremos modificar, incrementando
			el tamaño del documento a proporciones inaceptables y haciéndolo imposible de
			mantener y actualizar. Solo imagine lo que ocurriría si decide que en lugar de <b> 20 pixeles</b> el
			tamaño de cada uno de los elementos <b><"p></b> debería ser de <b> 24 pixeles.</b> Tendría que
			modificar cada estilo en cada etiqueta <b><"/p></b> en el documento completo.
		</p><br>
	</article><hr><br><br><br><br><br>


	<article id="7">
		<h2>Estilos embebidos</h2>
		<p>
			Una mejor alternativa es insertar los estilos en la cabecera del documento y luego usar
			referencias para afectar los elementos HTML correspondientes:
		</p><br>
		<p>
			<img src= "media\figura curso de css 2.png" >
			<div class="figura"><b>Listado 2-2.</b>Estilos listados en la cabecera del documento.</div>
		</p><br>
		<p>
			El elemento <"style> (mostrado en el Listado 2-2) permite a los desarrolladores
			agrupar estilos CSS dentro del documento. En versiones previas de HTML era necesario
			especificar qué tipo de estilos serían insertados. En HTML5 los estilos por defecto son CSS,
			por lo tanto no necesitamos agregar ningún atributo en la etiqueta de apertura <"style>. <br><br>

			El código resaltado del Listado 2-2 tiene la misma función que la línea de código del
			Listado 2-1, pero en el Listado 2-2 no tuvimos que escribir el estilo dentro de cada
			etiqueta <b><"p> porque todos los elementos <"p></b> ya fueron afectados. Con este método,
			reducimos nuestro código y asignamos los estilos que queremos a elementos específicos
			utilizando referencias. Veremos más sobre referencias en este capítulo.
		</p><br>
	</article><hr><br><br><br><br><br>

	<article id="8">
		<h2>Archivos externos</h2>
		<p>
			Declarar los estilos en la cabecera del documento ahorra espacio y vuelve al código más
			consistente y actualizable, pero nos requiere hacer una copia de cada grupo de estilos en
			todos los documentos de nuestro sitio web. La solución es mover todos los estilos a un
			archivo externo y luego utilizar el elemento <"link> para insertar este archivo dentro de
			cada documento que los necesite. Este método nos permite cambiar los estilos por
			completo simplemente incluyendo un archivo diferente. También nos permite modificar o
			adaptar nuestros documentos a cada circunstancia o dispositivo, como veremos al final
			del libro.
		</p><br>
		<p>
			En el Capítulo 1, estudiamos la etiqueta <|link> y cómo utilizarla para insertar
			archivos con estilos CSS en nuestros documentos. Utilizando la línea <|link
			rel=”stylesheet” href=”misestilos.css”> le decimos al navegador que cargue el
			archivo misestilos.css porque contiene todos los estilos necesitados para presentar el
			documento en pantalla. Esta práctica fue ampliamente adoptada por diseñadores que ya
			están trabajando con HTML5. La etiqueta <|link> referenciando el archivo CSS será
			insertada en cada uno de los documentos que requieren de esos estilos:
		</p><br>
		<p>
			<img src="media/figura curso de css 3.png" alt="Aplicando estilos CSS desde un archivo externo.">
			<figure><b>Listado 2-3.</b>Aplicando estilos CSS desde un archivo externo</figure>
		</p><br>
		<p>
			<b> Hágalo usted mismo:</b> De ahora en adelante agregaremos estilos CSS al archivo
			llamado misestilos.css. Debe crear este archivo en el mismo directorio
			(carpeta) donde se encuentra el archivo HTML y copiar los estilos CSS en su
			interior para comprobar cómo trabajan. <br><br>

			<b> Conceptos básicos:</b> Los archivos CSS son archivos de texto comunes. Al igual que
			los archivos HTML, puede crearlos utilizando cualquier editor de texto como el
			Bloc de Notas de Windows, por ejemplo.
		</p><br>
	</article><hr><br><br><br><br><br>

	<article id="9">
		<h2>Referencias</h2>
		<p>
			Almacenar todos nuestros estilos en un archivo externo e insertar este archivo dentro de
			cada documento que lo necesite es muy conveniente, sin embargo no podremos hacerlo
			sin buenos mecanismos que nos ayuden a establecer una específica relación entre estos
			estilos y los elementos del documento que van a ser afectados.
		</p><br>
		<p>
			Cuando hablábamos sobre cómo incluir estilos en el documento, mostramos una de las
			técnicas utilizadas a menudo en CSS para referenciar elementos HTML. En el Listado 2-2, el
			estilo para cambiar el tamaño de la letra referenciaba cada elemento <|p> usando la palabra
			clave p. De esta manera el estilo insertado entre las etiquetas <|style> referenciaba cada
			etiqueta <|p> del documento y asignaba ese estilo particular a cada una de ellas.
		</p>
		<ul>Existen varios métodos para seleccionar cuáles elementos HTML serán afectados por
			las reglas CSS: <br><br>
			<li>referencia por la palabra clave del elemento.</li>
			<li>referencia por el atributo id.</li>
			<li>referencia por el atributo class.</li>
		</ul><br><br>
		<p>
			Más tarde veremos que CSS3 es bastante flexible a este respecto e incorpora nuevas y
			más específicas técnicas para referenciar elementos, pero por ahora aplicaremos solo
			estas tres.
		</p>
	</article><hr><br><br><br><br><br>
	
	<article id="10">
		<h2>Referenciando con palabra clave</h2>
		<p>
			Al declarar las reglas CSS utilizando la palabra clave del elemento afectamos cada
			elemento de la misma clase en el documento. Por ejemplo, la siguiente regla cambiará los
			estilos de todos los elementos <|p>:
		</p><br><br>
		<p>
			<img src="media/figura curso de css 4.png" alt="Referenciando por palabra clave." width="auto">
			<figure><b>Listado 2-4. </b>Referenciando por palabra clave.</figure>
		</p><br><br>
		<p>
			Esta es la técnica presentada previamente en el Listado 2-2. Utilizando la palabra clave
			p al frente de la regla le estamos diciendo al navegador que esta regla debe ser aplicada a
			cada elemento <|p> encontrado en el documento HTML. Todos los textos envueltos en
			etiquetas <|p> tendrán el tamaño de 20 pixeles. <br><br>
			Por supuesto, lo mismo funcionará para cualquier otro elemento HTML. Si
			especificamos la palabra clave span en lugar de p, por ejemplo, cada texto entre etiquetas
			<|span> tendrá un tamaño de 20 pixeles: <br><br>

			<img src="media/fugura curso de css 5.png" alt="Referenciando por otra palabra clave.">
			<figure> <b>Listado 2-5.</b> Referenciando por otra palabra clave.</figure>
		</p><br><br>
		<p>
			¿Pero qué ocurre si solo necesitamos referenciar una etiqueta específica? ¿Debemos
			usar nuevamente el atributo style dentro de esta etiqueta? La respuesta es no. Como
			aprendimos anteriormente, el método de Estilos en Línea (usando el atributo style
			dentro de etiquetas HTML) es una técnica en desuso y debería ser evitada. Para
			seleccionar un elemento HTML específico desde las reglas de nuestro archivo CSS,
			podemos usar dos atributos diferentes: <b>id</b> y  <b>class</b>.
		</p>
	</article><hr><br><br><br><br><br>

	<article id="11">
		<h2>Referenciando con el atributo id</h2>
		<p>
			El atributo <b>id </b> es como un nombre que identifica al elemento. Esto significa que el valor de
			este atributo no puede ser duplicado. Este nombre debe ser único en todo el documento. <br><br>
			Para referenciar un elemento en particular usando el atributo id desde nuestro
			archivo <b>CSS</b>  la regla debe ser declarada con el símbolo <b>#</b>  al frente del valor que usamos
			para identificar el elemento: <br><br>

			<img src="media/fugura curso de css 6.png" alt="Referenciando a través del valor del atributo id.">
			<figure><b>Listado 2-6.</b> Referenciando a través del valor del atributo id.</figure>
		</p><br><br>
		<p>
			La regla en el Listado 2-6 será aplicada al elemento HTML identificado con el atributo
			<b>id=”texto1”</b>. Ahora nuestro código HTML lucirá de esta manera: <br><br>
		<img src="media/figura curso de css 7.png" alt=" Identificando el elemento <p> a través de su atributo id.">
		<figure><b>Listado 2-7.</b> Identificando el elemento <|p> a través de su atributo id.</figure><br><br>
			<p>
				El resultado de este procedimiento es que cada vez que hacemos una referencia
				usando el identificador <b>texto1</b> en nuestro archivo CSS, el elemento con ese valor de <b>id</b>

				será modificado, pero el resto de los elementos <|p>, o cualquier otro elemento en el mismo documento, no serán afectados. <br><br>
				Esta es una forma extremadamente específica de referenciar un elemento y es normalmente utilizada para elementos más generales, como etiquetas estructurales. El
				atributo id y su especificidad es de hecho más apropiado para referencias en Javascript, como veremos en próximos capítulos.
			</p><br><br>
		</p>
	</article><hr><br><br><br><br><br>


	<article id="12">
		<h2>Referenciando con el atributo class</h2>
		<p>
			La mayoría del tiempo, en lugar de utilizar el atributo <b> id</b> para propósitos de estilos es
			mejor utilizar <b>class.</b>  Este atributo es más flexible y puede ser asignado a cada elemento
			HTML en el documento que comparte un diseño similar: <br><br>

			<img src="media/figura curso de css 8.png" alt="Referenciando por el valor del atributo class.">
			<figure> <b>Listado 2-8.</b> Referenciando por el valor del atributo class.</figure>
		</p><br><br>
		<p>
			Para trabajar con el atributo class, debemos declarar la regla CSS con un punto antes del
			nombre. La ventaja de este método es que insertar el atributo class con el valor texto1 será
			suficiente para asignar estos estilos a cualquier elemento que queramos: <br><br>
			<img src="media/figura curso de css 9.png" alt="Asignando estilos a varios elementos a través del atributo class.">
			<figure> <b>Listado 2-9.</b> Asignando estilos a varios elementos a través del atributo class.</figure>
		</p><br><br>
		<p>
			Los elementos <|p> en las primeras dos líneas dentro del cuerpo del código en el
			Listado 2-9 tienen el atributo <b>class</b>  con el valor <b>texto1.</b>  Como dijimos previamente, la
			misma regla puede ser aplicada a diferentes elementos en el mismo documento. Por lo
			tanto, estos dos primeros elementos comparten la misma regla y ambos serán afectados
			por el estilo del Listado 2-8. El último elemento <|p> conserva los estilos por defecto
			otorgados por el navegador. <br><br>

			La razón por la que debemos utilizar un punto delante del nombre de la regla es que es
			posible construir referencias más complejas. Por ejemplo, se puede utilizar el mismo valor para
			el atributo class en diferentes elementos pero asignar diferentes estilos para cada tipo: <br><br>

			<img src="media/figura curso de css 10.png" alt="Referenciando solo elementos <p> a través del valor del atributo class.">
				<figure> <b>Listado 2-10.</b> Referenciando solo elementos <|p> a través del valor del atributo class.</figure>
		</p><br><br>
		<p>
			En el Listado 2-10 creamos una regla que referencia la clase llamada texto1 pero solo
			para los elementos de tipo <|p>. Si cualquier otro elemento tiene el mismo valor en su
			atributo class no será modificado por esta regla en particular.
		</p><br><br>
	</article><hr><br><br><br><br><br>

	<article id="13">
		<h2>Referenciando con cualquier atributo</h2>
		<p>
			Aunque los métodos de referencia estudiados anteriormente cubren un variado espectro
			de situaciones, a veces no son suficientes para encontrar el elemento exacto. La última
			versión de CSS ha incorporado nuevas formas de referenciar elementos HTML. Uno de
			ellas es el Selector de Atributo. Ahora podemos referenciar un elemento no solo por los
			atributos id y class sino también a través de cualquier otro atributo: <br><br>
			<img src="media/figura curso de css 11.png" alt="Referenciando solo elementos <p> que tienen el atributo name.">
				<figure> <b>Listado 2-11.</b> Referenciando solo elementos <|p> que tienen el atributo name.</figure>
		</p><br><br>
		<p>
			La regla en el Listado 2-11 cambia solo elementos <|p> que tienen un atributo llamado
			name. Para imitar lo que hicimos previamente con los atributos id y class, podemos
			también especificar el valor del atributo: <br><br>

			<img src="media/figura curso de css 12.png" alt="Referenciando elementos <p> que tienen un atributo name con el valor mitexto.">
				<figure><b>Listado 2-12.</b> Referenciando elementos <|p> que tienen un atributo name con el valor mitexto.</figure><br>
			<p>
				CSS3 permite combinar “=” con otros para hacer una selección más específica: <br><br>

				<img src="media/figura curso de css 13.png" alt="Nuevos selectores en CSS3.">
				<figure><b>Listado 2-13.</b> Nuevos selectores en CSS3.</figure>
			</p><br><br>
			<p>
			  Si usted conoce Expresiones Regulares desde otros lenguajes como Javascript o PHP,
			  podrá reconocer los selectores utilizados en el Listado 2-13. En CSS3 estos selectores
			  producen similares resultados: <br><br>
			  <ul>
				  <li><b> La regla con el selector ^=</b> será asignada a todo elemento <|p> que contiene un
				  atributo name con un valor comenzado en “mi” (por ejemplo, “mitexto”, “micasa”).</li>

				  <li><b>La regla con el selector $= </b>será asignada a todo elemento <|p> que contiene un
				  atributo name con un valor finalizado en “mi” (por ejemplo “textomi”, “casami”).</li>

				  <li><b>La regla con el selector *=</b> será asignada a todo elemento <|p> que contiene un
					  atributo name con un valor que incluye el texto “mi” (en este caso, el texto
					  podría también encontrarse en el medio, como en “textomicasa”).</li>
			  </ul>
			</p><br><br>
			<p>
			  En estos ejemplos usamos el elemento <|p>, el atributo name, y una cadena de texto al
			  azar como “mi”, pero la misma técnica puede ser utilizada con cualquier atributo y valor
			  que necesitemos. Solo tiene que escribir los corchetes e insertar entre ellos el nombre del
			  atributo y el valor que necesita para referenciar el elemento HTML correcto.
			</p><br><br>
		</p>
	</article><hr><br><br><br><br><br>


	<article id="14">
	  <h2>Nuevos selectores</h2>
	  <p>
		Hay algunos selectores más que fueron agregados o que ahora son considerados parte de
		CSS3 y pueden ser útiles para nuestros diseños. Estos selectores usan los símbolos >, + y ~
		para especificar la relación entre elementos. <br><br>
		<img src="media\figura curso de css 14.png" alt=" Selector >.">
		<figure>
		  <b>Listado 2-22.</b>
		   Selector >.
		</figure>
	  </p><br><br>
	  <p>
		El selector > está indicando que el elemento a ser afectado por la regla es el elemento
		de la derecha cuando tiene al de la izquierda como su padre. La regla en el Listado 2-22
		modifica los elementos <|p> que son hijos de un elemento <|div>. En este caso, fuimos
		bien específicos y referenciamos solamente el elemento <|p> con el valor mitexto2 en su
		atributo class. <br><br>
		El próximo ejemplo construye un selector utilizando el símbolo +. Este selector
		referencia al elemento de la derecha cuando es inmediatamente precedido por el de la
		izquierda. Ambos elementos deben compartir el mismo padre:<br><br>

		<img src="media\figura curso de css 15.png" alt="Selector +.">
		<figure>
		  <b>Listado 2-23.</b>
			Selector +.
		</figure>
	  </p><br><br>
	  <p>
		La regla del Listado 2-23 afecta al elemento <|p> que se encuentra ubicado luego de
		otro elemento <|p> identificado con el valor mitexto2 en su atributo class. Si abre en su
		navegador el archivo HTML con el código del Listado 2-14, el texto en el tercer elemento
		<|p> aparecerá en la pantalla en color rojo debido a que este elemento <|p> en particular
		está posicionado inmediatamente después del elemento <|p> identificado con el valor
		mitexto2 en su atributo class. <br><br>
		El último selector que estudiaremos es el construido con el símbolo ~. Este selector es
		similar al anterior pero el elemento afectado no necesita estar precediendo de inmediato
		al elemento de la izquierda. Además, más de un elemento puede ser afectado: <br><br>
		<img src="media\figura curso de css 16.png" alt="Selector ~.">
		<figure>
		  <b>Listado 2-24.</b>
		  Selector ~.
		</figure>
	  </p><br><br>
	  <p>
		La regla del Listado 2-24 afecta al tercer y cuarto elemento <|p> de nuestra plantilla de
		ejemplo. El estilo será aplicado a todos los elementos <|p> que son hermanos y se
		encuentran luego del elemento <|p> identificado con el valor mitexto2 en su atributo
		class. No importa si otros elementos se encuentran intercalados, los elementos <|p> en
		la tercera y cuarta posición aún serán afectados. Puede verificar esto último insertando un
		elemento <|span>mitexto<|/span> luego del elemento <|p> que tiene el valor mitexto2
		en su atributo class. A pesar de este cambio solo los elementos <|p> serán modificados
		por esta regla.
	  </p><br><br>
	</article><hr><br><br><br><br><br><br><br>

	<article id="15">
		<h2>Aplicando CSS a nuestra plantilla.</h2>

		<p>
			Como aprendimos más temprano en este mismo capítulo, todo elemento estructural es considerado una caja y la estructura completa es presentada como un grupo de cajas. Las cajas agrupadas constituyen lo que es llamado un Modelo de Caja. <br><br>
			Siguiendo con los conceptos básicos de CSS, vamos a estudiar lo que es llamado el
			Modelo de Caja Tradicional. Este modelo has sido implementado desde la primera versión
			de CSS y es actualmente soportado por cada navegador en el mercado, lo que lo ha
			convertido en un estándar para el diseño web. <br><br>
			Todo modelo, incluso aquellos aún en fase experimental, pueden ser aplicados a la
			misma estructura HTML, pero esta estructura debe ser preparada para ser afectada por
			estos estilos de forma adecuada. Nuestros documentos HTML deberán ser adaptados al
			modelo de caja seleccionado. <br><br>

			<b>IMPORTANTE:</b>El Modelo de Caja Tradicional presentado posteriormente no es una
			incorporación de HTML5, pero es introducido en este libro por ser el único disponible
			en estos momentos y posiblemente el que continuará siendo utilizado en sitios webs
			desarrollados en HTML5 durante los próximos años. Si usted ya conoce cómo
			implementarlo, siéntase en libertad de obviar esta parte del capítulo. <br><br>
		</p><br><br>
	</article><hr><br><br><br><br><br>

	<article id="16">
		<h2>Modelo de caja tradicional</h2>

		<p>
			Todo comenzó con tablas. Las tablas fueron los elementos que sin intención se volvieron la herramienta ideal utilizada por desarrolladores para crear y organizar cajas de contenido enla pantalla. Este puede ser considerado el primer modelo de caja de la web. Las cajas eran creadas expandiendo celdas y combinando filas de celdas, columnas de celdas y tablas enteras, unas sobre otras o incluso anidadas. Cuando los sitios webs crecieron y se volvieron más y más complejos esta práctica comenzó a presentar serios problemas relacionados con el tamaño y el mantenimiento del código necesario para crearlos. <br><br>

			Estos problemas iniciales hicieron necesario lo que ahora vemos como una práctica natural: la división entre estructura y presentación. Usando etiquetas <|div> y estilos CSS fue posible reemplazar la función de tablas y efectivamente separar la estructura HTML de la presentación. Con elementos <|div> y CSS podemos crear cajas en la pantalla, posicionar estas cajas a un lado o a otro y darles un tamaño, color o borde específico entre otras características. CSS provee propiedades específicas que nos permiten organizar las cajas acorde a nuestros deseos. Estas propiedades son lo suficientemente poderosas como para crear un modelo de caja que se transformó en lo que hoy conocemos como Modelo de Caja Tradicional. <br><br>

			Algunas deficiencias en este modelo mantuvieron a las tablas vivas por algún tiempo, pero los principales desarrolladores, influenciados por el suceso de las implementaciones Ajax y una cantidad enorme de nuevas aplicaciones interactivas, gradualmente volvieron a las etiquetas <|div> y estilos CSS en un estándar. Finalmente el Modelo de Caja Tradicional fue adoptado a gran escala. <br><br><hr><br><br><br><br><br>

			<h2 id="17">Plantilla</h2>
		<p>
			En el Capítulo 1 construimos una plantilla HTML5. Esta plantilla tiene todos los elementosnecesarios para proveer estructura a nuestro documento, pero algunos detalles deben seragregados para aplicar los estilos CSS y el Modelo de Caja Tradicional. <br><br>

			Este modelo necesita agrupar cajas juntas para ordenarlas horizontalmente. Debido a que el contenido completo del cuerpo es creado a partir de cajas, debemos agregar un elemento <|div> para agruparlas, centrarlas y darles un tamaño específico.La nueva plantilla lucirá de este modo:

				<pre>
					<code>
					<.!DOCTYPE html>
					<.html lang="es">
					<.head>
					<.meta charset="iso-8859-1">
					<.meta name="description" content="Ejemplo de HTML5">
					<.meta name="keywords" content="HTML5, CSS3, JavaScript">
					<.title>Este texto es el título del documento<./title>
					<.link rel="stylesheet" href="misestilos.css">
					<./head>
					<.body>
					<.div id="agrupar">
					<.header id="cabecera">
						<.h1>Este es el título principal del sitio web<./h1>
					<./header>
					<.nav id="menu">
					<.ul>
						<.li>principal<./li>
						<.li>fotos<./li>
						<.li>videos<./li>
						<.li>contacto<./li>
					<./ul>
					<./nav>
					<.section id="seccion">
					<.article>
					<.header>
					<.hgroup>
						<.h1>Título del mensaje uno<./h1>
						<.h2>Subtítulo del mensaje uno<./h2>
					<./hgroup>
					<.time datetime="2011-12-10" pubdate>publicado 10-12-2011
					<./time>
					<./header>
							Este es el texto de mi primer mensaje
					<.figure>
						<.img src="http://minkbooks.com/content/myimage.jpg">
					<.figcaption>
							Esta es la imagen del primer mensaje
					<./figcaption>
					<./figure>
					<.footer>
					<.p>comentarios (0)<./p>
					<./footer>
					<./article>
					<.article>
					<.header>
					<.hgroup>
						<.h1>Título del mensaje dos<./h1>
						<.h2>Subtítulo del mensaje dos<./h2>
					<./hgroup>
					<.time datetime="2011-12-15" pubdate>publicado 15-12-2011
					<./time>
					<./header>
							Este es el texto de mi segundo mensaje
					<.footer>
					<.p>comentarios (0)<./p>
					<./footer>
					<./article>
					<./section>
					<.aside id="columna">
						<.blockquote>Mensaje número uno<./blockquote>
						<.blockquote>Mensaje número dos<./blockquote>
					<./aside>
					<.footer id="pie">
							Derechos Reservados &.copy; 2010-2011
					<./footer>
					<./div>
					<./body>
					<./html>
				</code>
			</pre>
				<figure><b>Listado 2-25.</b> Nueva plantilla HTML5 lista para estilos CSS.</figure>
		</p>
		</p><br><br>
		<p>
			El Listado 2-25 provee una nueva plantilla lista para recibir los estilos CSS. Dos cambios
			importantes pueden distinguirse al comparar este código con el del Listado 1-18 del
			Capítulo 1. El primero es que ahora varias etiquetas fueron identificadas con los atributos
			id y class. Esto significa que podemos referenciar un elemento específico desde las
			reglas CSS con el valor de su atributo id o podemos modificar varios elementos al mismo
			tiempo usando el valor de su atributo class. <br><br>

			El segundo cambio realizado a la vieja plantilla es la adición del elemento <.div>
			mencionado anteriormente. Este <.div> fue identificado con el atributo y el valor
			id=”agrupar”, y es cerrado al final del cuerpo con la etiqueta de cierre <./div>. Este
			elemento se encarga de agrupar todos los demás elementos permitiéndonos aplicar el
			modelo de caja al cuerpo y designar su posición horizontal, como veremos más adelante. <br><br><br>
			
			 <b> Hágalo usted mismo:</b> Compare el código del Listado 1-18 del Capítulo 1 con el código en el Listado 2-25 de este capítulo y ubique las etiquetas de apertura y cierre del elemento <.div> utilizado para agrupar al resto.También compruebe cuáles elementos se encuentran ahora identificados con el atributo id y cuáles con el atributo class. Confirme que los valores de los atributos id son únicos para cada etiqueta. También necesitará reemplazar el código en el archivo HTML creado anteriormente por el del Listado 2-25 para aplicar los siguientes estilos CSS. <br><br>

			  Con el documento HTML finalizado es tiempo de trabajar en nuestro archivo de estilos. <br><br><br>
		</p><hr><br><br><br><br><br>
		<p>
			<h2 id="18">Selector universal *</h2>
			<p>
				Comencemos con algunas reglas básicas que nos ayudarán a proveer consistencia al diseño: <br><br>
			</p>
			<pre class="ejemplos-largos">
				<code>
					* {
						margin: 0px;
						padding: 0px;
					}
				</code>
			</pre><br>
			
		</p><br><br>
		
		<div class="figura"><b>Listado 2-26.</b> Regla CSS general.</div>

		<p>
			Normalmente, para la mayoría de los elementos, necesitamos personalizar los márgenes o simplemente mantenerlos al mínimo. Algunos elementos por defecto tienen márgenes que son diferentes de cero y en la mayoría de los casos demasiado amplios. A medida que avanzamos en la creación de nuestro diseño encontraremos que la mayoría de los elementos utilizados deben tener un margen de 0 pixeles. Para evitar el tener que repetir estilos constantemente, podemos utilizar el selector universal. <br><br>

			La primera regla en nuestro archivo CSS, presentada en el Listado 2-26, nos asegura que todo elemento tendrá un margen interno y externo de 0 pixeles. De ahora en más solo necesitaremos modificar los márgenes de los elementos que queremos que sean mayores que cero. <br><br>

			<p>
			   <b>Conceptos básicos: </b> Recuerde que en HTML cada elemento es considerado como
				una caja. El margen (margin) es en realidad el espacio alrededor del elemento, el
				que se encuentra por fuera del borde de esa caja (el estilo padding, por otro
				lado, es el espacio alrededor del contenido del elemento pero dentro de sus
				bordes, como el espacio entre el título y el borde de la caja virtual formada por el
				elemento <.h1> que contiene ese título). El tamaño del margen puede ser
				definido por lados específicos del elemento o todos sus lados a la vez. <br><br>

			   <b>El estilo margin: </b> 0px en nuestro ejemplo establece un margen 0 o nulo para cada
				elemento de la caja. Si el tamaño hubiese sido especificado en 5 pixeles, por
				ejemplo, la caja tendría un espacio de 5 pixeles de ancho en todo su contorno.
				Esto significa que la caja estaría separada de sus vecinas por 5 pixeles.
				Volveremos sobre este tema más adelante en este capítulo. <br><br>

			   <b>Hágalo usted mismo: </b> Debemos escribir todas las reglas necesarias para otorgar
				estilo a nuestra plantilla en un archivo CSS. El archivo ya fue incluido dentro del
				código HTML por medio de la etiqueta <.link>, por lo que lo único que tenemos
				que hacer es crear un archivo de texto vacío con nuestro editor de textos
				preferido, grabarlo con el nombre misestilos.css y luego copiar en su interior
				la regla del Listado 2-26 y todas las presentadas a continuación.
			</p><br><br>
		</p><hr><br><br><br><br><br>
		<p>
			<h2 id="19">Nueva jerarquía para cabeceras</h2>

			<p>
				En nuestra plantilla usamos elementos <.h1> y <.h2> para declarar títulos y subtítulos de
				diferentes secciones del documento. Los estilos por defecto de estos elementos se
				encuentran siempre muy lejos de lo que queremos y además en HTML5 podemos
				reconstruir la jerarquía H varias veces en cada sección (como aprendimos en el capítulo
				anterior). El elemento <.h1>, por ejemplo, será usado varias veces en el documento, no
				solo para el título principal de la página web como pasaba anteriormente sino también
				para secciones internas, por lo que tenemos que otorgarle los estilos apropiados: <br><br>

				<pre class="ejemplos-largos">
					<code>
						h1 {
						font: bold 20px verdana, sans-serif;
						}

						h2 {
						font: bold 14px verdana, sans-serif;
						}
					</code>
				</pre>
				<figure><b>Listado 2-27.</b> Agregando estilos para los elementos <.h1> y <.h2>.</figure><br><br>
				<p>
					La propiedad font, asignada a los elementos <.h1> y <.h2> en el Listado 2-27, nos
					permite declarar todos los estilos para el texto en una sola línea. Las propiedades que
					pueden ser declaradas usando font son: font-style, font-variant, font-weight,
					font-size/line-height, y font-family en este orden. Con estas reglas estamos
					cambiando el grosor, tamaño y tipo de letra del texto dentro de los elementos <.h1> y
					<.h2> a los valores que deseamos. <br><br>
				 </p>
			</p>
		</p><hr><br><br><br><br><br>
		<p>
			<h2 id="20">Declarando nuevos elementos HTML5</h2>

			<p>
				Otra regla básica que debemos declarar desde el comienzo es la definición por defecto de
				elementos estructurales de HTML5. Algunos navegadores aún no reconocen estos elementos o
				los tratan como elementos inline (en línea). Necesitamos declarar los nuevos elementos
				HTML5 como elementos block para asegurarnos de que serán tratados como regularmente se
				hace con elementos <.div> y de este modo construir nuestro modelo de caja: <br><br>

					<pre class="ejemplos-largos">
						<code>
							header, section, footer, aside, nav, article, figure, figcaption,
							hgroup{
							display: block;
							}
						</code>
					</pre>
					<figure><b>Listado 2-28.</b> Regla por defecto para elementos estructurales de HTML5.</figure>
			</p><br><br>
			<p>
			   A partir de ahora, los elementos afectados por la regla del Listado 2-28 serán posicionados uno sobre otro a menos que especifiquemos algo diferente más adelante. 
			</p><br><br>
		</p><hr><br><br><br><br><br>
		<p>
			<h2 id="21">Centrando el cuerpo</h2>

			<p>
				El primer elemento que es parte del modelo de caja es siempre <.body>. Normalmente, por
				diferentes razones de diseño, el contenido de este elemento debe ser posicionado
				horizontalmente. Siempre deberemos especificar el tamaño de este contenido, o un tamaño
				máximo, para obtener un diseño consistente a través de diferentes configuraciones de
				pantalla. <br><br>

				<pre class="ejemplos-largos">
					<code>
						body {
						text-align: center;
						}
					</code>
				</pre>
			<figure><b>Listado 2-29.</b> Centrando el cuerpo.</figure><br><br>
			<p>
				Por defecto, la etiqueta <.body> (como cualquier otro elemento block) tiene un valor
				de ancho establecido en 100%. Esto significa que el cuerpo ocupará el ancho completo de
				la ventana del navegador. Por lo tanto, para centrar la página en la pantalla necesitamos
				centrar el contenido dentro del cuerpo. Con la regla agregada en el Listado 2-29, todo lo que se encuentra dentro de <.body> será centrado en la ventana, centrando de este modo toda la página web.
			</p><br><br>
			</p>
		</p><hr><br><br><br><br><br>
		<p>
			<h2 id="22">Creando la caja principal</h2>
			<p>
				Siguiendo con el diseño de nuestra plantilla, debemos especificar una tamaño o tamaño
				máximo para el contenido del cuerpo. Como seguramente recuerda, en el Listado 2-25 en este
				mismo capítulo agregamos un elemento <.div> a la plantilla para agrupar todas las cajas
				dentro del cuerpo. Este <.div> será considerado la caja principal para la construcción de
				nuestro modelo de caja (este es el propósito por el que lo agregamos). De este modo,
				modificando el tamaño de este elemento lo hacemos al mismo tiempo para todos los demás: <br><br>
				<pre id="ejemplos-largos">
					<code>
						#agrupar {
						width: 960px;
						margin: 15px auto;
						text-align: left;
						}
					</code>
				</pre>
				<figure><b>Listado 2-30.</b> Definiendo las propiedades de la caja principal.</figure>
				<p>
					La regla en el Listado 2-30 está referenciando por primera vez un elemento a través del
					valor de su atributo id. El carácter # le está diciendo al navegador que el elemento
					afectado por este conjunto de estilos tiene el atributo id con el valor agrupar.
					Esta regla provee tres estilos para la caja principal. El primer estilo establece un valor
					fijo de 960 pixeles. Esta caja tendrá siempre un ancho de 960 pixeles, lo que representa un
					valor común para un sitio web estos días (los valores se encuentran entre 960 y 980
					pixeles de ancho, sin embargo estos parámetros cambian constantemente a través del
					tiempo, por supuesto). <br><br>

					El segundo estilo es parte de lo que llamamos el Modelo de Caja Tradicional. En la
					regla previa (Listado 2-29), especificamos que el contenido del cuerpo sería centrado
					horizontalmente con el estilo text-align: center. Pero esto solo afecta contenido
					inline, como textos o imágenes. Para elementos block, como un <.div>, necesitamos
					establecer un valor específico para sus márgenes que los adapta automáticamente al
					tamaño de su elemento padre. La propiedad margin usada para este propósito puede
					tener cuatro valores: superior, derecho, inferior, izquierdo, en este orden. Esto significa
					que el primer valor declarado en el estilo representa el margen de la parte superior del
					elemento, el segundo es el margen de la derecha, y así sucesivamente. Sin embargo, si
					solo escribimos los primeros dos parámetros, el resto tomará los mismos valores. En
					nuestro ejemplo estamos usando esta técnica. <br><br>

					En el Listado 2-30, el estilo margin: 15px auto asigna 15 pixeles al margen superior
					e inferior del elemento <.div> que está afectando y declara como automático el tamaño
					de los márgenes de izquierda y derecha (los dos valores declarados son usados para
					definir los cuatro márgenes). De esta manera, habremos generado un espacio de 15 pixeles en la parte superior e inferior del cuerpo y los espacios a los laterales (margen
					izquierdo y derecho) serán calculados automáticamente de acuerdo al tamaño del cuerpo
					del documento y el elemento <.div>, efectivamente centrando el contenido en pantalla.
					La página web ya está centrada y tiene un tamaño fijo de 960 pixeles. <br><br>

					Lo próximo que
					necesitamos hacer es prevenir un problema que ocurre en algunos navegadores. <br><br>

					La propiedad text-align es hereditaria. Esto significa que todos los elementos dentro del
					cuerpo y su contenido serán centrados, no solo la caja principal. El estilo asignado a <.body>
					en el Listado 2-29 será asignado a cada uno de sus hijos. Debemos retornar este estilo a su
					valor por defecto para el resto del documento. El tercer y último estilo incorporado en la
					regla del Listado 2-30 (text-align: left) logra este propósito. El resultado final es que el
					contenido del cuerpo es centrado pero el contenido de la caja principal (el <.div>
					identificado como agrupar) es alineado nuevamente hacia la izquierda, por lo tanto todo el
					resto del código HTML dentro de esta caja hereda este estilo. <br><br>

					<ul>
						<p>
							<b>Hágalo usted mismo: </b>Si aún no lo ha hecho, copie cada una de las reglas listadas
							hasta este punto dentro de un archivo de texto vacío llamado misestilos.css.
							Este archivo debe estar ubicado en el mismo directorio (carpeta) que el archivo
							HTML con el código del Listado 2-25. Al terminar, deberá contar con dos archivos,
							uno con el código HTML y otro llamado misestilos.css con todos los estilos
							CSS estudiados desde el Listado 2-26. Abra el archivo HTML en su navegador y en
							la pantalla podrá notar la caja creada.
						</p>
					</ul>
				</p>
			</p>
		</p><hr><br><br>
		<p>
			<h2 id="23">La cabecera</h2>
			<p>
				Continuemos con el resto de los elementos estructurales. Siguiendo la etiqueta de
				apertura del <.div> principal se encuentra el primer elemento estructural de HTML5:
				<.header>. Este elemento contiene el título principal de nuestra página web y estará
				ubicado en la parte superior de la pantalla. En nuestra plantilla, <.header> fue
				identificado con el atributo id y el valor cabecera. <br><br>
				Como ya mencionamos, cada elemento block, así como el cuerpo, por defecto tiene un
				valor de ancho del 100%. Esto significa que el elemento ocupará todo el espacio horizontal
				disponible. En el caso del cuerpo, ese espacio es el ancho total de la pantalla visible (la
				ventana del navegador), pero en el resto de los elementos el espacio máximo disponible
				estará determinado por el ancho de su elemento padre. En nuestro ejemplo, el espacio
				máximo disponible para los elementos dentro de la caja principal será de 960 pixeles,
				porque su padre es la caja principal la cual fue previamente configurada con este tamaño. <br><br>

				<pre>
						<code>  
							#cabecera {
							background: #FFFBB9;
							border: 1px solid #999999;
							padding: 20px;
							}
						</code>
				</pre>
				<figure><b>Listado 2-31.</b> Agregando estilos para <.header>.</figure>
			</p><br><br>
			<p>
				Debido a que <.header> ocupará todo el espacio horizontal disponible en la caja
				principal y será tratado como un elemento block (y por esto posicionada en la parte
				superior de la página), lo único que resta por hacer es asignar estilos que nos permitirán
				reconocer el elemento cuando es presentado en pantalla. En la regla mostrada en el
				Listado 2-31 le otorgamos a <.header> un fondo amarillo, un borde sólido de 1 pixel y un
				margen interior de 20 pixeles usando la propiedad padding.
			</p><hr><br><br>
			<p>
				<h2 id="24">Barra de navegación</h2>
				<p>
					Siguiendo al elemento <.header> se encuentra el elemento <.nav>, el cual tiene el
					propósito de proporcionar ayuda para la navegación. Los enlaces agrupados dentro de
					este elemento representarán el menú de nuestro sitio web. Este menú será una simple
					barra ubicada debajo de la cabecera. Por este motivo, del mismo modo que el elemento
					<.header>, la mayoría de los estilos que necesitamos para posicionar el elemento <.nav>
					ya fueron asignados: <.nav> es un elemento block por lo que será ubicado debajo del
					elemento previo, su ancho por defecto será 100% por lo que será tan ancho como su
					padre (el <.div> principal), y (también por defecto) será tan alto como su contenido y los
					márgenes predeterminados. Por lo tanto, lo único que nos queda por hacer es mejorar su
					aspecto en pantalla. Esto último lo logramos agregando un fondo gris y un pequeño
					margen interno para separar las opciones del menú del borde del elemento: <br><br>

					<pre>
						<code>
							#menu {
							background: #CCCCCC;
							padding: 5px 15px;
							}
							#menu li {
							display: inline-block;
							list-style: none;
							padding: 5px;
							font: bold 14px verdana, sans-serif;
							}
						</code>
					</pre>
					<figure><b>Listado 2-32.</b> Agregando estilos para <.nav>. En el Listado 2-32, la primera regla referencia al elemento <.nav> por su atributo id, <br> cambia su color de fondo y agrega márgenes internos de 5px y 15px con la propiedad padding. </figure><br><br>

						<p>
							Conceptos básicos: La propiedad padding trabaja exactamente como margin.
							Cuatro valores pueden ser especificados: superior, derecho, inferior, izquierdo,
							en este orden. Si solo declaramos un valor, el mismo será asignado para todos los
							espacios alrededor del contenido del elemento. Si en cambio especificamos dos
							valores, entonces el primero será asignado como margen interno de la parte
							superior e inferior del contenido y el segundo valor será asignado al margen
							interno de los lados, izquierdo y derecho. <br><br>

							Dentro de la barra de navegación hay una lista creada con las etiquetas <.ul> y <.li>. Por
							defecto, los ítems de una lista son posicionados unos sobre otros. Para cambiar este
							comportamiento y colocar cada opción del menú una al lado de la otra, referenciamos los
							elementos <.li> dentro de este elemento <.nav> en particular usando el selector #menu
							li, y luego asignamos a todos ellos el estilo display: inline-block para convertirlos en
							lo que se llama cajas inline. A diferencia de los elementos block, los elementos afectados por
							el parámetro inline-block estandarizado en CSS3 no generan ningún salto de línea pero
							nos permiten tratarlos como elementos block y así declarar un valor de ancho determinado.
							Este parámetro también ajusta el tamaño del elemento de acuerdo con su contenido cuando
							el valor del ancho no fue especificado. <br><br>

							En esta última regla también eliminamos el pequeño gráfico generado por defecto por los navegadores delante de cada opción del listado utilizando la propiedad list-style. <br><br>
						</p>
				</p>  
			</p>
		</p><hr><br><br>

		<p>
			<h2 id="25">Section y aside</h2>
			<p>
				Los siguientes elementos estructurales en nuestro código son dos cajas ordenadas
				horizontalmente. El Modelo de Caja Tradicional es construido sobre estilos CSS que nos
				permiten especificar la posición de cada caja. Usando la propiedad float podemos
				posicionar estas cajas del lado izquierdo o derecho de acuerdo a nuestras necesidades. Los
				elementos que utilizamos en nuestra plantilla HTML para crear estas cajas son <.section>
				y <.aside>, cada uno identificado con el atributo id y los valores seccion y columna
				respectivamente. <br><br>

				<pre>	
					<code>  
						#seccion {
						float: left;
						width: 660px;
						margin: 20px;
						}
						#columna {
						float: left;
						width: 220px;
						margin: 20px 0px;
						padding: 20px;
						background: #CCCCCC;
						}
					</code>
				</pre>
				<figure class="figura"><b>Listado 2-33.</b> Creando dos columnas con la propiedad float.</figure>
			</p><br><br>
			<p>
				La propiedad de CSS float es una de las propiedades más ampliamente utilizadas
				para aplicar el Modelo de Caja Tradicional. Hace que el elemento flote hacia un lado o al
				otro en el espacio disponible. Los elementos afectados por float actúan como elementos
				block (con la diferencia de que son ubicados de acuerdo al valor de esta propiedad y no el
				flujo normal del documento). Los elementos son movidos a izquierda o derecha en el área
				disponible, tanto como sea posible, respondiendo al valor de float. <br><br>

				Con las reglas del Listado 2-33 declaramos la posición de ambas cajas y sus respectivos
				tamaños, generando así las columnas visibles en la pantalla. La propiedad float mueve la
				caja al espacio disponible del lado especificado por su valor, width asigna un tamaño
				horizontal y margin, por supuesto, declara el margen del elemento. <br><br>

				Afectado por estos valores, el contenido del elemento <.section> estará situado a la
				izquierda de la pantalla con un tamaño de 660 pixeles, más 40 pixeles de margen,
				ocupando un espacio total de 700 pixeles de ancho. <br><br>

				La propiedad float del elemento <.aside> también tiene el valor left (izquierda).
				Esto significa que la caja generada será movida al espacio disponible a su izquierda.
				Debido a que la caja previa creada por el elemento <.section> fue también movida a la
				izquierda de la pantalla, ahora el espacio disponible será solo el que esta caja dejó libre. La
				nueva caja quedará ubicada en la misma línea que la primera pero a su derecha, ocupando
				el espacio restante en la línea, creando la segunda columna de nuestro diseño. <br><br>

				El tamaño declarado para esta segunda caja fue de 220 pixeles. También agregamos
				un fondo gris y configuramos un margen interno de 20 pixeles. Como resultado final, el
				ancho de esta caja será de 220 pixeles más 40 pixeles agregados por la propiedad
				padding (los márgenes de los lados fueron declarados a 0px). <br><br>
			</p>
		</p><hr><br><br>

				
			

		 
		<p>
			<h2 id="26">Footer</h2>
			<p>
				Para finalizar la aplicación del Modelo de Caja Tradicional, otra propiedad CSS tiene que ser
				aplicada al elemento <.footer>. Esta propiedad devuelve al documento su flujo normal y nos
				permite posicionar <.footer> debajo del último elemento en lugar de a su lado: <br><br>
					<pre>
						<code>
							#pie {
							clear: both;
							text-align: center;
							padding: 20px;
							border-top: 2px solid #999999;
							}
						</code>
					</pre>
					
			</p>
			<div class="figura"><b>Listado 2-34.</b> Otorgando estilos a <.footer> y recuperando el normal flujo del documento.</div>
			<p>
				La regla del Listado 2-34 declara un borde de 2 pixeles en la parte superior de
				<.footer>, un margen interno (padding) de 20 pixeles, y centra el texto dentro del
				elemento. A sí mismo, restaura el normal flujo del documento con la propiedad clear.
				Esta propiedad simplemente restaura las condiciones normales del área ocupada por el
				elemento, no permitiéndole posicionarse adyacente a una caja flotante. El valor
				usualmente utilizado es both, el cual significa que ambos lados del elemento serán
				restaurados y el elemento seguirá el flujo normal (este elemento ya no es flotante como
				los anteriores). Esto, para un elemento block, quiere decir que será posicionado debajo del
				último elemento, en una nueva línea. <br><br>
				La propiedad clear también empuja los elementos verticalmente, haciendo que las
				cajas flotantes ocupen un área real en la pantalla. Sin esta propiedad, el navegador
				presenta el documento en pantalla como si los elementos flotantes no existieran y las
				cajas se superponen. <br><br>
			</p>
		</p>
	<div class="figura2-2">

					<section class="cabecera">
						<p class="uno">display:block</p>
					</section>

					<section class="cabecera2">
						<p class="2">display:block</p>
					</section>

					<section class="cuerpo">

						<article class="cuerpo1">
							<p>display:block</p>
							<p> float:left</p>
						</article>

						<article class="cuerpo2">
							<p>display:block</p>
							<p>float:left</p>
						</article>
						
					</section>
					

				
					<section class="pies">
						<p>display:block</p>
						<p>clear:both</p>
					</section>
	</div>
	<figure><b>Figura 2-2.</b> Representación visual del modelo de caja tradicional.</figure><br><br><br>
	<p>
		Cuando tenemos cajas posicionadas una al lado de la otra en el Modelo de Caja
		Tradicional siempre necesitamos crear un elemento con el estilo clear: both para
		poder seguir agregando otras cajas debajo de un modo natural. La Figura 2-2 muestra una
		representación visual de este modelo con los estilos básicos para lograr la correcta
		disposición en pantalla. <br><br>

		Los valores left (izquierda) y right (derecha) de la propiedad float no significan
		que las cajas deben estar necesariamente posicionadas del lado izquierdo o derecho de la
		ventana. Lo que los valores hacen es volver flotante ese lado del elemento, rompiendo el
		flujo normal del documento. Si el valor es left, por ejemplo, el navegador tratará de
		posicionar el elemento del lado izquierdo en el espacio disponible. Si hay espacio
		disponible luego de otro elemento, este nuevo elemento será situado a su derecha,
		porque su lado izquierdo fue configurado como flotante. El elemento flota hacia la
		izquierda hasta que encuentra algo que lo bloquea, como otro elemento o el borde de su
		elemento padre. Esto es importante cuando queremos crear varias columnas en la
		pantalla. En este caso cada columna tendrá el valor left en la propiedad float para
		asegurar que cada columna estará continua a la otra en el orden correcto. De este modo,
		cada columna flotará hacia la izquierda hasta que es bloqueada por otra columna o el
		borde del elemento padre. <br><br><br>
	</p>
	</article><hr><br><br>

	<article id="27">
		<h2>Últimos toques</h2>
		<p>
			Lo único que nos queda por hacer es trabajar en el diseño del contenido. Para esto, solo
			necesitamos configurar los pocos elementos HTML5 restantes: <br><br>

			<pre>
				<code>
					article {
					background: #FFFBCC;
					border: 1px solid #999999;
					padding: 20px;
					margin-bottom: 15px;
					}
					article footer {
					text-align: right;
					}
					time {
					color: #999999;
					}
					figcaption {
					font: italic 14px verdana, sans-serif;
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 2-35.</b> Agregando los últimos toques a nuestro diseño básico.</figure><br><br>
		<p>
			La primera regla del Listado 2-35 referencia todos los elementos <.rticle> y les
			otorga algunos estilos básicos (color de fondo, un borde sólido de 1 pixel, margen internoy margen inferior). El margen inferior de 15 pixeles tiene el propósito de separar un
			elemento <.article> del siguiente verticalmente. <br><br>

			Cada elemento <.article> cuenta también con un elemento <-footer> que muestra
			el número de comentarios recibidos. Para referenciar un elemento <.footer> dentro de
			un elemento <.article>, usamos el selector article footer que significa “cada
			<.footer> dentro de un <.article> será afectado por los siguientes estilos”. Esta técnica
			de referencia fue aplicada aquí para alinear a la derecha el texto dentro de los elementos
			<.footer> de cada <.article>. <br><br>

			Al final del código en el Listado 2-35 cambiamos el color de cada elemento <.time> y
			diferenciamos la descripción de la imagen (insertada con el elemento <.figcaption>) del
			resto del texto usando una tipo de letra diferente. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b> Si aún no lo ha hecho, copie cada regla CSS listada en este
				capítulo desde el Listado 2-26, una debajo de otra, dentro del archivo
				misestilos.css, y luego abra el archivo HTML con la plantilla creada en el
				Listado 2-25 en su navegador. Esto le mostrará cómo funciona el Modelo de Caja
				Tradicional y cómo los elementos estructurales son organizados en pantalla.
			</ul><br><br>
			<ul>
				<b>IMPORTANTE:</b> Puede acceder a estos códigos con un solo clic desde nuestro sitio
				web. Visite www.minkbooks.com.
			</ul>
			</p>
	</article><hr><br><br>

	<article id="28">
		<h2>Box-sizing</h2>
		<p>
			Existe una propiedad adicional incorporada en CSS3 relacionada con la estructura y el
			Modelo de Caja Tradicional. La propiedad box-sizing nos permite cambiar cómo el
			espacio total ocupado por un elemento en pantalla será calculado forzando a los
			navegadores a incluir en el ancho original los valores de las propiedades padding y
			border. <br><br>

			Como explicamos anteriormente, cada vez que el área total ocupada por un elemento
			es calculada, el navegador obtiene el valor final por medio de la siguiente fórmula:
			tamaño + márgenes + márgenes internos + bordes. <br><br>
			
			Por este motivo, si declaramos la propiedad width igual a 100 pixeles, margin en 20
			pixeles, padding en 10 pixeles y border en 1 pixel, el área horizontal total ocupada por el
			elemento será: 100+40+20+2= 162 pixeles (note que tuvimos que duplicar los valores de
			margin, padding y border en la fórmula porque consideramos que los mismos fueron
			asignados tanto para el lado derecho como el izquierdo). <br><br>

			Esto significa que cada vez que declare el ancho de un elemento con la propiedad
			width, deberá recordar que el área real para ubicar el elemento en pantalla será
			seguramente más grande. <br><br>

			Dependiendo de sus costumbres, a veces podría resultar útil forzar al navegador a
			incluir los valores de padding y border en el tamaño del elemento. En este caso la nueva
			fórmula sería simplemente: tamaño + márgenes. <br><br>

			<pre>
				<code>
					div {
					width: 100px;
					margin: 20px;
					padding: 10px;
					border: 1px solid #000000;<br><br>
					<strong>
					-moz-box-sizing: border-box;
					-webkit-box-sizing: border-box;
					box-sizing: border-box;
					}
					</strong>
				</code>
			</pre>
		</p>
		<figure><b>Listado 2-36.</b> Incluyendo padding y border en el tamaño del elemento.</figure>
		<p>
			La propiedad box-sizing puede tomar dos valores. Por defecto es configurada como
			content-box, lo que significa que los navegadores agregarán los valores de padding y
			border al tamaño especificado por width y height. Usando el valor border-box en su
			lugar, este comportamiento es cambiado de modo que padding y border son incluidos
			dentro del elemento. <br><br>

			El Listado 2-36 muestra la aplicación de esta propiedad en un elemento <.div>. Este es
			solo un ejemplo y no vamos a usarlo en nuestra plantilla, pero puede ser útil para algunos
			diseñadores dependiendo de qué tan familiarizados se encuentran con los métodos
			tradicionales propuestos por versiones previas de CSS. <br><br>

			<ul>
				<b>IMPORTANTE:</b> En este momento, la propiedad box-sizing, al igual que otras
				importantes propiedades CSS3 estudiadas en próximos capítulos, se encuentra en
				estado experimental en algunos navegadores. Para aplicarla efectivamente a sus
				documentos, debe declararla con los correspondientes prefijos, como hicimos en
				el Listado 2-36. Los prefijos para los navegadores más comunes son los
				siguientes: <br><br>

				<ul>
					<li>-moz- para Firefox.</li>
					<li>-webkit- para Safari y Chrome.-o- para Opera.</li>
					<li>-khtml- para Konqueror.</li>
					<li>-ms- para Internet Explorer.</li>
					<li>-chrome- específico para Google Chrome.</li>
				</ul>

			</ul>
		</p>
		
	</article><hr><br><br>

	<!--
		referencias parte 2 del capitulo 2
	-->

	<article id="29">
		<h2>Referencia rápida</h2>
		<p>
			En HTML5 la responsabilidad por la presentación de la estructura en pantalla está más que
			nunca en manos de CSS. Incorporaciones y mejoras se han hecho en la última versión de
			CSS para proveer mejores formas de organizar documentos y trabajar con sus elementos. <br><br>
		</p>

		<p id="30">
			<h2>Selector de atributo y pseudo clases</h2>
			<p>
				CSS3 incorpora nuevos mecanismos para referenciar elementos HTML. <br><br>
			</p>

			<ul>
				<b>Selector de Atributo</b> Ahora podemos utilizar otros atributos además de id y class para
				encontrar elementos en el documento y asignar estilos. Con la construcción
				palabraclave[atributo=valor], podemos referenciar un elemento que tiene un
				atributo particular con un valor específico. Por ejemplo, p[name=”texto”]
				referenciará cada elemento <.p> con un atributo llamado name y el valor ”texto”.
				CSS3 también provee técnicas para hacer esta referencia aún más específica. Usando
				las siguientes combinaciones de símbolos ^=, $= y *= podemos encontrar elementos
				que comienzan con el valor provisto, elementos que terminan con ese valor y
				elementos que tienen el texto provisto en alguna parte del valor del atributo. Por
				ejemplo, p[name^=”texto”] será usado para encontrar elementos <.p> que tienen
				un atributo llamado name con un valor que comienza por ”texto”.
			</ul><br><br>
			<ul>
				<b>Pseudo Clase :nth-child()</b>Esta pseudo clase encuentra un hijo específico siguiendo la
				estructura de árbol de HTML. Por ejemplo, con el estilo span:nth-child(2)
				estamos referenciando el elemento <.span> que tiene otros elementos <.span> como
				hermanos y está localizado en la posición 2. Este número es considerado el índice. En
				lugar de un número podemos usar las palabras clave odd y even para referenciar
				elementos con un índice impar o par respectivamente (por ejemplo, span:nth-
				child(odd)).
			</ul><br><br>
			<ul>
				<b>Pseudo Clase :first-child</b>Esta pseudo clase es usada para referenciar el primer hijo, similar
				a :nth-child(1).
			</ul><br><br>
			<ul>
				<b>Pseudo Clase :last-child</b>Esta pseudo clase es usada para referenciar el último hijo.
			</ul><br><br>
			<ul>
				<b>Pseudo Clase :only-child</b>Esta pseudo clase es usada para referenciar un elemento que es
				el único hijo disponible de un mismo elemento padre.
			</ul><br><br>
			<ul>
				<b>Pseudo Clase :not()</b>Esta pseudo clase es usada para referenciar todo elemento excepto el
				declarado entre paréntesis.
			</ul>
			
		</p>
	</article><hr><br><br>

	<article id="31">
		<h2>Selectores</h2>
		<p>
			CSS3 también incorpora nuevos selectores que ayudan a llegar a elementos difíciles de
			referenciar utilizando otras técnicas. <br><br>

			<ul>
				<b>Selector ></b>Este selector referencia al elemento de la derecha cuando tiene el elemento de
				la izquierda como padre. Por ejemplo, div > p referenciará cada elemento <.p> que
				es hijo de un elemento <.div>.
			</ul><br><br>
			<ul>
				<b>Selector +</b>Este selector referencia elementos que son hermanos. La referencia apuntará al
				elemento de la derecha cuando es inmediatamente precedido por el de la izquierda.
				Por ejemplo, span + p afectará a los elementos <.p> que son hermanos y están
				ubicados luego de un elemento <.span>.
			</ul><br><br>	
			<ul>
				<b>Selector ~ </b>Este selector es similar al anterior, pero en este caso el elemento de la derecha
				no tiene que estar ubicado inmediatamente después del de la izquierda.
			</ul><br><br>
		</p>
	</article><hr><br><br>



	<!--
			capitulo 3 de css3
	-->



	<article id="32">
		<h1>Las nuevas reglas</h1>
		<p>
			La web cambió para siempre cuando unos años atrás nuevas aplicaciones desarrolladas
			sobre implementaciones Ajax mejoraron el diseño y la experiencia de los usuarios. La
			versión 2.0, asignada a la web para describir un nuevo nivel de desarrollo, representó un
			cambio no solo en la forma en que la información era transmitida sino también en cómo
			los sitios web y nuevas aplicaciones eran diseñados y construidos. <br><br>

			Los códigos implementados en esta nueva generación de sitios web pronto se
			volvieron estándar. La innovación se volvió tan importante para el éxito de cualquier
			proyecto en Internet que programadores desarrollaron librerías completas para superar
			las limitaciones y satisfacer los nuevos requerimientos de los diseñadores. <br><br>

			La falta de soporte por parte de los navegadores era evidente, pero la organización
			responsable de los estándares web no tomó las tendencias muy seriamente e intentó
			seguir su propio camino. Afortunadamente, algunas mentes brillantes siguieron
			desarrollando nuevos estándares en paralelo y pronto HTML5 nació. Luego del retorno de
			la calma (y algunos acuerdos de por medio), la integración entre HTML, CSS y Javascript
			bajo la tutela de HTML5 fue como el caballero bravo y victorioso que dirige las tropas
			hacia el palacio enemigo. <br><br>

			A pesar de la reciente agitación, esta batalla comenzó mucho tiempo atrás, con la
			primera especificación de la tercera versión de CSS. Cuando finalmente, alrededor del año
			2005, esta tecnología fue oficialmente considerada estándar, CSS estaba listo para proveer
			las funciones requeridas por desarrolladores (aquellas que programadores habían creado
			desde años atrás usando códigos Javascript complicados de implementar y no siempre
			compatibles). <br><br>

			En este capítulo vamos a estudiar las contribuciones hechas por CSS3 a HTML5 y todas
			las propiedades que simplifican la vida de diseñadores y programadores. <br><br>
		</p>
	</article><hr><br><br>

	<article id="33">
		<h2>CSS3 se vuelve loco</h2>
		<p>
			CSS fue siempre sobre estilo, pero ya no más. En un intento por reducir el uso de código
			Javascript y para estandarizar funciones populares, CSS3 no solo cubre diseño y estilos
			web sino también forma y movimiento. La especificación de CSS3 es presentada en
			módulos que permiten a la tecnología proveer una especificación estándar por cadaaspecto involucrado en la presentación visual del documento. Desde esquinas
			redondeadas y sombras hasta transformaciones y reposicionamiento de los elementos ya
			presentados en pantalla, cada posible efecto aplicado previamente utilizando Javascript
			fue cubierto. Este nivel de cambio convierte CSS3 en una tecnología prácticamente inédita
			comparada con versiones anteriores. <br><br>

			Cuando la especificación de HTML5 fue escrita considerando CSS a cargo del diseño, la
			mitad de la batalla contra el resto de las especificaciones propuesta había sido ganada. <br><br>
		</p>
	</article><hr><br><br>

	<article id="34">
		<h2>Plantilla</h2>
		<p>
			Las nuevas propiedades CSS3 son extremadamente poderosas y deben ser estudiadas una
			por una, pero para facilitar su aprendizaje vamos a aplicar todas ellas sobre la misma
			plantilla. Por este motivo comenzaremos por crear un documento HTML sencillo con
			algunos estilos básicos: <br><br>

			<pre>
				<code>
					<.!DOCTYPE html>
					<.html lang="es">
					<.head>
					<.title>Nuevos Estilos CSS3<./title>
					<.link rel="stylesheet" href="nuevocss3.css">
					<./head>
					<.body>
					<.header id="principal">
					<.span id="titulo">Estilos CSS Web 2.0<./span>
					<./header>
					<./body>
					<./html>
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-1.</b> Una plantilla simple para probar nuevas propiedades.</figure>
		<p>
			Nuestro documento solo tiene una sección con un texto breve en su interior. El
			elemento <.header> usado en la plantilla podría ser reemplazado por <.div>, <.av>,
			<.section> o cualquier otro elemento estructural de acuerdo a la ubicación en el diseño y
			a su función. Luego de aplicar los estilos, la caja generada con el código del ejemplo del
			Listado 3-1 lucirá como una cabecera, por consiguiente decidimos usar <.header> en este
			caso. <br><br>

			Debido a que el elemento <.font> se encuentra en desuso en HTML5, los elementos
			usados para mostrar texto son normalmente <.span> para líneas cortas y <.p> para
			párrafos, entre otros. Por esta razón el texto en nuestra plantilla fue insertado usando
			etiquetas <.span>. <br><br>

				<ul>
					<b>Hágalo usted mismo:</b>Use el código provisto en el Listado 3-1 como la plantilla para
					este capítulo. Necesitará además crear un nuevo archivo CSS llamado
					nuevocss3.css para almacenar los estilos estudiados de aquí en adelante. <br><br>
				</ul>
		</p>
		<p>
			Los siguientes son los estilos básicos requeridos por nuestro documento HTML: <br><br>

			<pre>
				<code>
					body {
					text-align: center;
					}
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					}
					#titulo {
					font: bold 36px verdana, sans-serif;
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-2.</b> Reglas básicas CSS con las que comenzar.</figure>
		<p>
			No hay nada nuevo en las reglas del Listado 3-2, solo los estilos necesarios para dar
			forma a la plantilla y crear una caja ancha, posicionada en el centro de la ventana, con un
			fondo gris, un borde y un texto grande en su interior que dice “Estilos CSS Web 2.0”. <br><br>

			Una de las cosas que notará sobre esta caja cuando sea mostrada en pantalla es que
			sus esquinas son rectas. Esto no es algo que nos agrade, ¿verdad? Puede ser un factor
			psicológico o no, lo cierto es que a casi nadie en este negocio le agradan las esquinas
			rectas. Por lo tanto, lo primero que haremos será cambiar este aspecto. <br><br>
		</p>
	</article><hr><br><br>

	<article id="35">
		<h2>Border-radius</h2>
		<p>
			Por muchos años diseñadores han sufrido intentando lograr el efecto de esquinas
			redondeadas en las cajas de sus páginas web. El proceso era casi siempre frustrante y
			extenuante. Todos lo padecieron alguna vez. Si mira cualquier presentación en video de
			las nuevas características incorporadas en HTML5, cada vez que alguien habla sobre las
			propiedades de CSS3 que hacen posible generar fácilmente esquinas redondeadas, la
			audiencia enloquece. Esquinas redondeadas eran esa clase de cosas que nos hacían
			pensar: “debería ser fácil hacerlo”. Sin embargo nunca lo fue. <br><br>

			Esta es la razón por la que, entre todas las nuevas posibilidades e increíbles
			propiedades incorporadas en CSS3, la que exploraremos en primera instancia es border-
			radius: <br><br>

			<pre>
				<code>
					body {
					text-align: center;
					}
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-border-radius: 20px;
					-webkit-border-radius: 20px;
					border-radius: 20px;
					}
					#titulo {
					font: bold 36px verdana, sans-serif;
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-3.</b> Generando esquinas redondeadas.</figure>
		<p>
			La propiedad border-radius en este momento es experimental por lo que debemos
			usar los prefijos –moz- y -webkit- para que funcionen en navegadores basados en
			motores Gecko y WebKit, como Firefox, Safari y Google Chrome (los prefijos fueron
			estudiados y aplicados en el Capítulo 2). Si todas las esquinas tienen la misma curvatura
			podemos utilizar un solo valor. Sin embargo, como ocurre con las propiedades margin y
			padding, podemos también declarar un valor diferente por cada una: <br><br>

			<pre>
				<code>
					body {
					text-align: center;
					}
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-border-radius: 20px 10px 30px 50px;
					-webkit-border-radius: 20px 10px 30px 50px;
					border-radius: 20px 10px 30px 50px;
					}
					#titulo {
					font: bold 36px verdana, sans-serif;
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-4.</b> Diferentes valores para cada esquina.</figure>
		<p>
			Como puede ver en el Listado 3-4, los cuatro valores asignados a la propiedad
			border-radius representan diferentes ubicaciones. Recorriendo la caja en dirección de
			las agujas del reloj, los valores se aplicarán en el siguiente orden: esquina superior
			izquierda, esquina superior derecha, esquina inferior derecha y esquina inferior izquierda.
			Los valores son siempre dados en dirección de las agujas del reloj, comenzando por la
			esquina superior izquierda. <br><br>

			Al igual que con margin o padding, border-radius puede también trabajar solo
			con dos valores. El primer valor será asignado a la primera y tercera equina (superior
			izquierda, inferior derecha), y el segundo valor a la segunda y cuarta esquina (superior
			derecha, inferior izquierda). <br><br>

			También podemos dar forma a las esquinas declarando un segundo grupo de valores
			separados por una barra. Los valores a la izquierda de la barra representarán el radio
			horizontal mientras que los valores a la derecha representan el radio vertical. La
			combinación de estos valores genera una elipsis: <br><br>

			<pre>
				<code>
					body {
					text-align: center;
					}
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-border-radius: 20px / 10px;
					-webkit-border-radius: 20px / 10px;
					border-radius: 20px / 10px;
					}
					#titulo {
					font: bold 36px verdana, sans-serif;
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-5.</b> Esquinas elípticas.</figure>
		<p>
			<ul>
				<b>Hágalo usted mismo: </b> Copie dentro del archivo CSS llamado nuevocss3.css los
				estilos que quiera probar y abra el archivo HTML generado con el Listado 3-1 en
				su navegador para comprobar los resultados.
			</ul>
		</p>
	</article><hr><br><br>

	<article id="36">
		<h2>Box-shadow</h2>
		<p>
			Ahora que finalmente contamos con la posibilidad de generar bonitas esquinas para
			nuestras cajas podemos arriesgarnos con algo más. Otro muy buen efecto, que había sido extremadamente complicado de lograr hasta este momento, es sombras. Por años
			diseñadores han combinado imágenes, elementos y algunas propiedades CSS para generar
			sombras. Gracias a CSS3 y a la nueva propiedad box-shadow podremos aplicar sombras a
			nuestras cajas con solo una simple línea de código: <br><br>

			<pre>
				<code>	
					body {
					text-align: center;
					}
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-border-radius: 20px;
					-webkit-border-radius: 20px;
					border-radius: 20px;
					-moz-box-shadow: rgb(150,150,150) 5px 5px;
					-webkit-box-shadow: rgb(150,150,150) 5px 5px;
					box-shadow: rgb(150,150,150) 5px 5px;
					}
					#titulo {
					font: bold 36px verdana, sans-serif;
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-6.</b> Aplicando sombra a nuestra caja.</figure>
		<p>
			La propiedad box-shadow necesita al menos tres valores. El primero, que puede ver
			en la regla del Listado 3-6, es el color. Este valor fue construido aquí utilizando la función
			rgb() y números decimales, pero podemos escribirlo en números hexadecimales
			también, como hicimos previamente para otros parámetros en este libro. <br><br>

			Los siguientes dos valores, expresados en pixeles, establecen el desplazamiento de la
			sombra. Este desplazamiento puede ser positivo o negativo. Los valores indican,
			respectivamente, la distancia horizontal y vertical desde la sombra al elemento. Valores
			negativos posicionarán la sombra a la izquierda y arriba del elemento, mientras que
			valores positivos crearán la sombra a la derecha y debajo del elemento. Valores de 0 o
			nulos posicionarán la sombra exactamente detrás del elemento, permitiendo la
			posibilidad de crear un efecto difuminado a todo su alrededor. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b>Para probar los diferentes parámetros y posibilidades con los
			que contamos para asignar una sombra a una caja, copie el código del Listado 3-6
			dentro del archivo CSS y abra el archivo HTML con la plantilla del Listado 3-1 en su navegador. Puede experimentar cambiando los valores de la propiedad box-shadow
			y puede usar el mismo código para experimentar también con los nuevos parámetros
			estudiados a continuación. <br><br>
			</ul>
		</p>
		<p>
			La sombra que obtuvimos hasta el momento es sólida, sin gradientes o transparencias
			(no realmente como una sombra suele aparecer). Existen algunos parámetros más y
			cambios que podemos implementar para mejorar la apariencia de la sombra.
			Un cuarto valor que se puede agregar a la propiedad ya estudiada es la distancia de
			difuminación. Con este efecto ahora la sombra lucirá real. Puede intentar utilizar este
			nuevo parámetro declarando un valor de 10 pixeles a la regla del Listado 3-6, como en el
			siguiente ejemplo: <br><br>

			<pre>
				<code>
					box-shadow: rgb(150,150,150) 5px 5px 10px;
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-7.</b>Agregando el valor de difuminación a box-shadow.</figure>
		<p>
			Agregando otro valor más en pixeles al final de la propiedad desparramará la sombra.
			Este efecto cambia un poco la naturaleza de la sombra expandiendo el área que cubre. A
			pesar de que no recomendamos utilizar este efecto, puede ser aplicable en algunos
			diseños. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b>Intente agregar un valor de 20 pixeles al final del estilo del
			Listado 3-7 y combine este código con el código del Listado 3-6 para probarlo. <br><br>
			<b>IMPORTANTE:</b>Siempre recuerde que en este momento las propiedades estudiadas
			son experimentales. Para usarlas, debe declarar cada una agregando los prefijos
			correspondientes, como –moz- o -webkit-, de acuerdo al navegador que usa (en
			este ejemplo, Firefox o Google Chrome). <br><br>
			</ul>
		</p>
		<p>
			El último valor posible para box-shadow no es un número sino más bien una palabra
			clave: inset. Esta palabra clave convierte a la sombra externa en una sombra interna, lo
			cual provee un efecto de profundidad al elemento afectado. <br><br>

			<pre>
				<code>
					box-shadow: rgb(150,150,150) 5px 5px 10px inset;
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-8.</b> Sombra interna.</figure>
		<p>
			El estilo en el Listado 3-8 mostrará una sombra interna alejada del borde de la caja por
			unos 5 pixeles y con un efecto de difuminación de 10 pixeles. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b> Los estilos de los Listados 3-7 y 3-8 son solo ejemplos. Para
			comprobar los efectos en su navegador debe aplicar estos cambios al grupo
			completo de reglas presentado en el Listado 3-6. <br><br>

			<b>IMPORTANTE:</b> Las sombras no expanden el elemento o incrementan su tamaño,
			por lo que tendrá que controlar cuidadosamente que el espacio disponible es
			suficiente para que la sombra sea expuesta y correctamente dibujada en la
			pantalla. <br><br>
			</ul>
		</p>
	</article><hr><br><br>

	<article id="37">
		<h2>Text-shadow</h2>
		<p>
			Ahora que conoce todo acerca de sombras probablemente estará pensando en generar
			una para cada elemento de su documento. La propiedad box-shadow fue diseñada
			especialmente para ser aplicada en cajas. Si intenta aplicar este efecto a un elemento
			<.span>, por ejemplo, la caja invisible ocupada por este elemento en la pantalla tendrá
			una sombra, pero no el contenido del elemento. Para crear sombras para figuras
			irregulares como textos, existe una propiedad especial llamada text-shadow: <br><br>

			<pre>
				<code>
					body {
					text-align: center;
					}
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-border-radius: 20px;
					-webkit-border-radius: 20px;
					border-radius: 20px;
					-moz-box-shadow: rgb(150,150,150) 5px 5px 10px;
					-webkit-box-shadow: rgb(150,150,150) 5px 5px 10px;
					box-shadow: rgb(150,150,150) 5px 5px 10px;
					}
					#titulo {
					font: bold 36px verdana, sans-serif;
					text-shadow: rgb(0,0,150) 3px 3px 5px;
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-9. </b>Generando una sombra para el título.</figure>
		<p>
			Los valores para text-shadow son similares a los usados para box-shadow. Podemos
			declarar el color de la sombra, la distancia horizontal y vertical de la sombra con respecto
			al objeto y el radio de difuminación. <br>

			En el Listado 3-9 una sombra azul fue aplicada al título de nuestra plantilla con una
			distancia de 3 pixeles y un radio de difuminación de 5. <br><br>
		</p>
	</article><hr><br><br>

	<article id="38">
		<h2>@font-face</h2>
		<p>
			Obtener un texto con sombra es realmente un muy buen truco de diseño, imposible de
			lograr con métodos previos, pero más que cambiar el texto en sí mismo solo provee un
			efecto tridimensional. Una sombra, en este caso, es como pintar un viejo coche, al final
			será el mismo coche. En este caso, será el mismo tipo de letra. <br><br>

			El problema con las fuentes o tipos de letra es tan viejo como la web. Usuarios regulares
			de la web a menudo tienen un número limitado de fuentes instaladas en sus ordenadores,
			usualmente estas fuentes son diferentes de un usuario a otro, y la mayoría de las veces
			muchos usuarios tendrán fuentes que otros no. Por años, los sitios webs solo pudieron
			utilizar un limitado grupo de fuentes confiables (un grupo básico que prácticamente todos
			los usuarios tienen instalados) y así presentar la información en pantalla. <br><br>

			La propiedad @font-face permite a los diseñadores proveer un archivo conteniendo
			una fuente específica para mostrar sus textos en la página. Ahora podemos incluir
			cualquier fuente que necesitemos con solo proveer el archivo adecuado: <br><br>

			<pre>
				<code>
					body {
					text-align: center;
					}
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-border-radius: 20px;
					-webkit-border-radius: 20px;
					border-radius: 20px;
					-moz-box-shadow: rgb(150,150,150) 5px 5px 10px;
					-webkit-box-shadow: rgb(150,150,150) 5px 5px 10px;
					box-shadow: rgb(150,150,150) 5px 5px 10px;
					}
					#titulo {
					font: bold 36px MiNuevaFuente, verdana, sans-serif;
					text-shadow: rgb(0,0,150) 3px 3px 5px;
					}

					@font-face {
					font-family: 'MiNuevaFuente';
					src: url('font.ttf');
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-10. </b>Nueva fuente para el título.</figure>
		<p>
			<ul>
				<b>Hágalo usted mismo:</b>Descargue el archivo font.ttf desde nuestro sitio web o
				use uno que ya posea y cópielo en el mismo directorio (carpeta) de su archivo
				CSS. Para descargar el archivo, visite el siguiente enlace: www.minkbooks.com/
				content/font.ttf. Puede obtener más fuentes similares de forma gratuita en
				www.moorstation.org/typoasis/designers/steffmann/. <br><br>

				<b>IMPORTANTE:</b>El archivo conteniendo la fuente debe encontrarse en el mismo
				dominio que la página web (o en el mismo ordenador, en este caso). Esta es una
				restricción de algunos navegadores como Firefox, por ejemplo. <br><br>
			</ul>
		</p>
		<p>
			La propiedad @font-face necesita al menos dos estilos para declarar la fuente y
			cargar el archivo. El estilo construido con la propiedad font-family especifica el nombre
			que queremos otorgar a esta fuente en particular, y la propiedad src indica la URL del
			archivo con el código correspondiente a esa fuente. En el Listado 3-10, el nombre
			MiNuevaFuente fue asignado a nuestro nuevo tipo de letra y el archivo font.ttf fue
			indicado como el archivo correspondiente a esta fuente. <br><br>

			Una vez que la fuente es cargada, podemos comenzar a usarla en cualquier elemento
			del documento simplemente escribiendo su nombre (MiNuevaFuente). En el estilo font
			en la regla del Listado 3-10, especificamos que el título será mostrado con la nueva fuente
			o las alternativas verdana y sans-serif en caso de que la fuente incorporada no sea
			cargada apropiadamente. <br><br>
		</p>
	</article><hr><br><br>

	<article id="39">
		<h2>Gradiente lineal</h2>
		<p>
			Los gradientes son uno de los efectos más atractivos entre aquellos incorporados en CSS3.
			Este efecto era prácticamente imposible de implementar usando técnicas anteriores pero
			ahora es realmente fácil de hacer usando CSS. Una propiedad background con algunos
			pocos parámetros es suficiente para convertir su documento en una página web con
			aspecto profesional: <br><br>

			<pre>
				<code>
					body {
					text-align: center;
					}
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-border-radius: 20px;
					-webkit-border-radius: 20px;
					border-radius: 20px;
					-moz-box-shadow: rgb(150,150,150) 5px 5px 10px;
					-webkit-box-shadow: rgb(150,150,150) 5px 5px 10px;
					box-shadow: rgb(150,150,150) 5px 5px 10px;
					background: -webkit-linear-gradient(top, #FFFFFF, #006699);
					background: -moz-linear-gradient(top, #FFFFFF, #006699);
					}
					#titulo {
					font: bold 36px MiNuevaFuente, verdana, sans-serif;
					text-shadow: rgb(0,0,150) 3px 3px 5px;
					}
					@font-face {
					font-family: 'MiNuevaFuente';
					src: url('font.ttf');
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-11. </b>Agregando un hermoso gradiente de fondo a nuestra caja.</figure>
		<p>
			Los gradientes son configurados como fondos, por lo que podemos usar las
			propiedades background o background-image para declararlos. La sintaxis para los
			valores declarados en estas propiedades es linear-gradient(posición inicio,
			color inicial, color final). Los atributos de la función linear-gradient()
			indican el punto de comienzo y los colores usados para crear el gradiente. El primer valor
			puede ser especificado en pixeles, porcentaje o usando las palabras clave top, bottom,
			left y right (como hicimos en nuestro ejemplo). El punto de comienzo puede ser
			reemplazado por un ángulo para declarar una dirección específica del gradiente: <br><br>

			<pre>
				<code>
					background: linear-gradient(30deg, #FFFFFF, #006699);
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-12. </b>Gradiente con un ángulo de dirección de 30 grados.</figure>
		<p>
			También podemos declarar los puntos de terminación para cada color: <br><br>

			<pre>
				<code>
					background: linear-gradient(top, #FFFFFF 50%, #006699 90%);
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-13. </b>Declarando puntos de terminación.</figure>

	</article><hr><br><br>

	<article id="40">
		<h2>Gradiente radial</h2>
		<p>
			La sintaxis estándar para los gradientes radiales solo difiere en unos pocos aspectos con
			respecto a la anterior. Debemos usar la función radial-gradient() y un nuevo
			atributo para la forma: <br><br>

			<pre>
				<code>
					background: radial-gradient(center, circle, #FFFFFF 0%, #006699 200%);
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-14. </b>Gradiente radial.</figure>
		<p>
			La posición de comienzo es el origen y puede ser declarada en pixeles, porcentaje o
			una combinación de las palabras clave center, top, bottom, left y right. Existen dos
			posibles valores para la forma (circle y ellipse) y la terminación para el color indica el
			color y la posición donde las transiciones comienzan. <br><br>

			<ul>
				<b>Hágalo usted mismo: </b>Reemplace el correspondiente código del Listado 3-11 por el
				código del Listado 3-14 para probar el efecto en su navegador (no olvide agregar los
				prefijos –moz- o -webkit- dependiendo del navegador que esté usando). <br><br>

				<b>IMPORTANTE</b>En este momento el efecto de gradientes ha sido implementado por
				los navegadores en diferentes formas. Lo que hemos aprendido en este capítulo es
				el estándar propuesto por W3C (World Wide Web Consortium). Navegadores como
				Firefox y Google Chrome ya incorporan una implementación que trabaja con este
				estándar, pero Internet Explorer y otros aún se encuentran ocupados en ello. Como
				siempre, pruebe sus códigos en cada navegador disponible en el mercado para
				comprobar el estado actual de las diferentes implementaciones. <br><br>
			</ul>
		</p>
	</article><hr><br><br>

	<article id="41">
		<h2>RGBA</h2>
		<p>
			Hasta este momento los colores fueron declarados como sólidos utilizando valores
			hexadecimales o la función rgb() para decimales. CSS3 ha agregado una nueva función
			llamada rgba() que simplifica la asignación de colores y transparencias. Esta función
			además resuelve un problema previo provocado por la propiedad opacity. <br><br>

			La función rgba() tiene cuatro atributos. Los primeros tres son similares a los usados
			en rgb() y simplemente declaran los valores para los colores rojo, verde y azul en
			números decimales del 0 al 255. El último, en cambio, corresponde a la nueva capacidad
			de opacidad. Este valor se debe encontrar dentro de un rango que va de 0 a 1, con 0 como
			totalmente transparente y 1 como totalmente opaco. <br><br>

			<pre>
				<code>
					#titulo {
					font: bold 36px MiNuevaFuente, verdana, sans-serif;
					ext-shadow: rgba(0,0,0,0.5) 3px 3px 5px;
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-15. Mejorando la sombra del texto con transparencia.</b>Mejorando la sombra del texto con transparencia.</figure>
		<p>
			El Listado 3-15 ofrece un simple ejemplo que demuestra cómo los efectos son
			mejorados aplicando transparencia. Reemplazamos la función rgb() por rgba() en la
			sombra del título y agregamos un valor de opacidad/transparencia de 0.5. Ahora la
			sombra de nuestro título se mezclará con el fondo, creando un efecto mucho más natural. <br><br>

			En previas versiones de CSS teníamos que usar diferentes técnicas en diferentes
			navegadores para hacer un elemento transparente. Todas presentaban el mismo
			problema: el valor de opacidad de un elemento era heredado por sus hijos. Ese problema
			fue resuelto por rgba() y ahora podemos asignar un valor de opacidad al fondo de una
			caja sin afectar su contenido. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b>Reemplace el correspondiente código del Listado 3-11 por
				el código del Listado 3-15 para probar el efecto en su navegador.
			</ul>
		</p>
	</article><hr><br><br>

	<article id="42">
		<h2>HSLA</h2>
		<p>
			Del mismo modo que la función rgba() agrega un valor de opacidad a rgb(), la función
			hsla() hace lo mismo para la función hsl(). <br><br>

			La función hsla() es simplemente un función diferente para generar colores, pero es
			más intuitiva que rgba(). Algunos diseñadores encontrarán más fácil generar un set de
			colores personalizado utilizando hsla(). La sintaxis de esta función es: hsla(tono,
			saturación, luminosidad, opacidad). <br><br>

			<pre>
				<code>
					#titulo {
					font: bold 36px MiNuevaFuente, verdana, sans-serif;
					text-shadow: rgba(0,0,0,0.5) 3px 3px 5px;
					color: hsla(120, 100%, 50%, 0.5);
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-16. </b>Nuevo color para el título usando hsla().</figure>
		<p>
			Siguiendo la sintaxis, tono representa el color extraído de una rueda imaginaria y es
			expresado en grados desde 0 a 360. Cerca de 0 y 360 están los colores rojos, cerca de 120
			los verdes y cerca de 240 los azules. El valor saturación es representado en porcentaje,
			desde 0% (escala de grises) a 100% (todo color o completamente saturado). La
			luminosidad es también un valor en porcentaje desde 0% (completamente oscuro) a
			100% (completamente iluminado). El valor 50% representa luminosidad normal o
			promedio. El último valor, así como en rgba(), representa la opacidad. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b>Reemplace el correspondiente código del Listado 3-11 por
				el código del Listado 3-16 para probar el efecto en su navegador. <br><br>
			</ul>
		</p>
	</article><hr><br><br>

	<article id="43">
		<h2>Outline</h2>
		<p>
			La propiedad outline es una vieja propiedad CSS que ha sido expandida en CSS3 para
			incluir un valor de desplazamiento. Esta propiedad era usada para crear un segundo
			borde, y ahora ese borde puede ser mostrado alejado del borde real del elemento. <br><br>

			<pre>
				<code>
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					outline: 2px dashed #000099;
					outline-offset: 15px;
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-17. </b>Agregando un segundo borde a la cabecera.</figure>
		<p>
			En el Listado 3-17 agregamos a los estilos originalmente aplicados a la caja de nuestra
			plantilla un segundo borde de 2 pixeles con un desplazamiento de 15 pixeles. La propiedad
			outline tiene similares características y usa los mismos parámetros que border. La
			propiedad outline-offset solo necesita un valor en pixeles. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b>Reemplace el correspondiente código del Listado 3-11 por
			el código del Listado 3-17 para probar el efecto en su navegador. <br><br>
			</ul>
		</p>
	</article><hr><br><br>

	<article id="44">
		<h2>Border-image</h2>
		<p>
			Los posibles efectos logrados por las propiedades border y outline están limitados a
			líneas simples y solo algunas opciones de configuración. La nueva propiedad border-image
			fue incorporada para superar estas limitaciones y dejar en manos del diseñador la calidad y
			variedad de bordes disponibles ofreciendo la alternativa de utilizar imágenes propias. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b>Vamos a utilizar una imagen PNG que incluye diamantes
			para probar esta propiedad. Siga el siguiente enlace para descargar el archivo
			diamonds.png desde nuestro sitio web y luego copie este archivo en el mismo
			directorio (carpeta) donde se encuentra su archivo CSS: www.minkbooks.com/
			content/diamonds.png. <br><br>


			La propiedad border-image toma una imagen y la utiliza como patrón. De acuerdo a
			los valores otorgados, la imagen es cortada como un pastel, las partes obtenidas son luego
			ubicadas alrededor del objeto para construir el borde. <br><br>


			<strong> Aqui va una figura que despues hago, si Dios quiere.</strong><br><br>



			</ul>
		</p>
		<figure><b>Figura 3-1. </b>Este es el patrón desde el cual vamos a construir nuestro borde. Cada pieza es de 29 pixeles de ancho, como indica la figura.</figure>

		<p>
			Para hacer el trabajo, necesitamos especificar tres atributos: el nombre del archivo de
			la imagen, el tamaño de las piezas que queremos obtener del patrón y algunas palabras
			clave para declarar cómo las piezas serán distribuidas alrededor del objeto. <br><br>

			<pre>
				<code>
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 29px;
					-moz-border-image: url("diamonds.png") 29 stretch;
					-webkit-border-image: url("diamonds.png") 29 stretch;
					border-image: url("diamonds.png") 29 stretch;
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-18. </b>Un borde personalizado para la cabecera.</figure>

		<p>
			Con las modificaciones realizadas en el Listado 3-18 estamos definiendo un borde de
			29 pixeles para la caja de nuestra cabecera y luego cargando la imagen diamonds.png
			para construir ese borde. El valor 29 en la propiedad border-image declara el tamaño de
			las piezas y stretch es uno de los métodos disponibles para distribuir estas piezas
			alrededor de la caja. <br><br>

			Existen tres valores posibles para el último atributo. La palabra clave repeat repetirá
			las piezas tomadas de la imagen todas las veces que sea necesario para cubrir el lado del
			elemento. En este caso, el tamaño de las piezas es preservado y la imagen será cortada si
			no existe más espacio para ubicarla. La palabra clave round considerará qué tan largo es
			el lado a ser cubierto y ajustará el tamaño de las piezas para asegurarse que cubren todo
			el lado y ninguna pieza es cortada. Finalmente, la palabra clave stretch (usada en el
			Listado 3-18) estira solo una pieza para cubrir el lado completo. <br><br>

			En nuestro ejemplo utilizamos la propiedad border para definir el tamaño del borde,
			pero se puede también usar border-with para especificar diferentes tamaños para cada
			lado del elemento (la propiedad border-with usa cuatro parámetros, con una sintaxis
			similar a margin y padding). Lo mismo ocurre con el tamaño de cada pieza, hasta cuatro
			valores pueden ser declarados para obtener diferentes imágenes de diferentes tamaños
			desde el patrón. <br><br>

			<ul>
				<b>Hágalo usted mismo: </b>Reemplace el correspondiente código del Listado 3-11 por
			el código del Listado 3-18 para probar el efecto en su navegador.
			</ul>
		</p>
	</article><hr><br><br>

	<article id="45">
		<h2>Transform y transition</h2>
		<p>
			Los elementos HTML, cuando son creados, son como bloques sólidos e inamovibles.
			Pueden ser movidos usando código Javascript o aprovechando librerías populares como
			jQuery (www.jquery.com), por ejemplo, pero no existía un procedimiento estándar para
			este propósito hasta que CSS3 presentó las propiedades transform y transition. <br><br>

			Ahora ya no tenemos que pensar en cómo hacerlo. En su lugar, solo tenemos que
			conocer cómo ajustar unos pocos parámetros y nuestro sitio web puede ser tan flexible y
			dinámico como lo imaginamos. <br><br>

			La propiedad transform puede operar cuatro transformaciones básicas en un
			elemento: scale (escalar), rotate (rotar), skew (inclinar) y translate (trasladar o
			mover). Veamos cómo funcionan: <br><br>

			
			<b>Transform: scale</b><br><br>
			<pre>
				<code>
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-transform: scale(2);
					-webkit-transform: scale(2);
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-19. </b>Cambiando la escala de la caja de la cabecera.</figure>
		<p>
			En el ejemplo del Listado 3-19 partimos de los estilos básicos utilizados para la
			cabecera generada en el Listado 3-2 y aplicamos transformación duplicando la escala del
			elemento. La función scale recibe dos parámetros: el valor X para la escala horizontal y el
			valor Y para la escala vertical. Si solo un valor es provisto el mismo valor es aplicado a
			ambos parámetros. <br><br>

			Números enteros y decimales pueden ser declarados para la escala. Esta escala es
			calculada por medio de una matriz. Los valores entre 0 y 1 reducirán el elemento, un valor
			de 1 mantendrá las proporciones originales y valores mayores que 1 aumentarán las
			dimensiones del elemento de manera incremental. <br><br>

			Un efecto atractivo puede ser logrado con esta función otorgando valores negativos: <br><br>

			<pre>
				<code>
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-transform: scale(1,-1);
					-webkit-transform: scale(1,-1);
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-20. </b>Creando una imagen espejo con scale.</figure>
		<p>
			En el Listado 3-20, dos parámetros han sido declarados para cambiar la escala de la
			caja principal. El primer valor, 1, mantiene la proporción original para la dimensión
			horizontal de la caja. El segundo valor también mantiene la proporción original, pero
			invierte el elemento verticalmente para producir el efecto espejo. <br><br>

			Existen también otras dos funciones similares a scale pero restringidas a la dimensión
			horizontal o vertical: scaleX y scaleY. Estas funciones, por supuesto, utilizan un solo
			parámetro. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b>Reemplace el correspondiente código del Listado 3-11 por
			el código del Listado 3-19 o 3-20 para probar el efecto en su navegador.
			</ul>
		</p>
	</article><hr><br><br>

	<article id="46">
		<h2>Transform: rotate</h2>
		<p>
			La función rotate rota el elemento en la dirección de las agujas de un reloj. El valor debe
			ser especificado en grados usando la unidad “deg”: <br><br>
			<pre>
				<code>
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-transform: rotate(30deg);
					-webkit-transform: rotate(30deg);
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-21. </b>Rotando la caja.</figure>
		<p>
			Si un valor negativo es declarado, solo cambiará la dirección en la cual el elemento es
			rotado. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b>Reemplace el correspondiente código del Listado 3-11 por
				el código del Listado 3-21 para probar el efecto en su navegador. <br><br>
			</ul>
		</p>
	</article><hr><br><br>

	<article id="47">
		<h2>Transform: skew</h2>
		<p>
			Esta función cambia la simetría del elemento en grados y en ambas dimensiones. <br><br>

			<pre>
				<code>
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-transform: skew(20deg);
					-webkit-transform: skew(20deg);
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-22. </b>Inclinar horizontalmente.</figure>
		<p>
			La función skew usa dos parámetros, pero a diferencia de otras funciones, cada
			parámetro de esta función solo afecta una dimensión (los parámetros actúan de forma
			independiente). En el Listado 3-22, realizamos una operación transform a la caja de la
			cabecera para inclinarla. Solo declaramos el primer parámetro, por lo que solo la dimensión
			horizontal de la caja será modificada. Si usáramos los dos parámetros, podríamos alterar
			ambas dimensiones del objeto. Como alternativa podemos utilizar funciones diferentes para
			cada una de ellas: skewX y skewY. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b>Reemplace el correspondiente código del Listado 3-11 por
				el código del Listado 3-22 para probar el efecto en su navegador. <br><br>
			</ul>
		</p>
	</article><hr><br><br>


	<article id="48">
		<h2>Transform: translate</h2>
		<p>
			Similar a las viejas propiedades top y left, la función translate mueve o desplaza el
			elemento en la pantalla a una nueva posición. <br><br>

			<pre>
				<code>
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-transform: translate(100px);
					-webkit-transform: translate(100px);
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-23.</b>Moviendo la caja de la cabecera hacia la derecha.</figure>
		<p>
			La función translate considera la pantalla como una grilla de pixeles, con la posición
			original del elemento usada como un punto de referencia. La esquina superior izquierda
			del elemento es la posición 0,0, por lo que valores negativos moverán al objeto hacia la
			izquierda o hacia arriba de la posición original, y valores positivos lo harán hacia la
			derecha o hacia abajo. <br><br>

			En el Listado 3-23, movimos la caja de la cabecera hacia la derecha unos 100 pixeles
			desde su posición original. Dos valores pueden ser declarados en esta función si queremos
			mover el elemento horizontal y verticalmente, o podemos usar funciones independientes
			llamadas translateX y translateY. <br><br>

			<ul>
				<b>Hágalo usted mismo:</b>Reemplace el correspondiente código del Listado 3-11 por
			el código del Listado 3-23 para probar el efecto en su navegador.
			</ul>
		</p>
	</article><hr><br><br>


	<article id="49">
		<h2>Transformando todo al mismo tiempo</h2>
		<p>
			A veces podría resultar útil realizar sobre un elemento varias transformaciones al mismo
			tiempo. Para obtener una propiedad transform combinada, solo tenemos que separar
			cada función a aplicar con un espacio: <br><br>

			<pre>
				<code>
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-transform: translateY(100px) rotate(45deg) scaleX(0.3);
					-webkit-transform: translateY(100px) rotate(45deg) scaleX(0.3);
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-24. </b>Moviendo, escalando y rotando el elemento con solo una línea de código.</figure>
		<p>
			Una de las cosas que debe recordar en este caso es que el orden es importante. Esto
			es debido a que algunas funciones mueven el punto original y el centro del objeto,
			cambiando de este modo los parámetros que el resto de las funciones utilizarán para
			operar. <br><br>

			<ul>
				<b>Hágalo usted mismo: </b>Reemplace el correspondiente código del Listado 3-11 por
el código del Listado 3-24 para probar el efecto en su navegador.
			</ul>
		</p>
	</article><hr><br><br>


	<article id="50">
		<h2>Transformaciones dinámicas</h2>
		<p>
			Lo que hemos aprendido hasta el momento en este capítulo cambiará la forma de la web,
			pero la mantendrá tan estática como siempre. Sin embargo, podemos aprovecharnos de la
			combinación de transformaciones y pseudo clases para convertir nuestra página en una
			aplicación dinámica: <br><br>

			<pre>
				<code>
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					}
					#principal:hover{
					-moz-transform: rotate(5deg);
					-webkit-transform: rotate(5deg);
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-25. </b>Respondiendo a la actividad del usuario.</figure>
		<p>
			En el Listado 3-25, la regla original del Listado 3-2 para la caja de la cabecera fue
			conservada intacta, pero una nueva regla fue agregada para aplicar efectos de transformación usando la vieja pseudo clase :hover. El resultado obtenido es que cada vez que el puntero del
			ratón pasa sobre esta caja, la propiedad transform rota la caja en 5 grados, y cuando el
			puntero se aleja la caja vuelve a rotar de regreso a su posición original. Este efecto produce una
			animación básica pero útil con nada más que propiedades CSS. <br><br>

			<ul>
				<b>Hágalo usted mismo: </b>Reemplace el correspondiente código del Listado 3-11 por
				el código del Listado 3-25 para probar el efecto en su navegador.
			</ul>
		</p>
	</article><hr><br><br>


	<article id="51">
		<h2>Transiciones</h2>
		<p>
			De ahora en más, hermosos efectos usando transformaciones dinámicas son accesibles y
			fáciles de implementar. Sin embargo, una animación real requiere de un proceso de más
			de dos pasos <br><br>

			La propiedad transition fue incluida para suavizar los cambios, creando
			mágicamente el resto de los pasos que se encuentran implícitos en el movimiento. Solo
			agregando esta propiedad forzamos al navegador a tomar cartas en el asunto, crear para
			nosotros todos esos pasos invisibles, y generar una transición suave desde un estado al
			otro. <br><br>

			<pre>
				<code>
					#principal {
					display: block;
					width: 500px;
					margin: 50px auto;
					padding: 15px;
					text-align: center;
					border: 1px solid #999999;
					background: #DDDDDD;
					-moz-transition: -moz-transform 1s ease-in-out 0.5s;
					-webkit-transition: -webkit-transform 1s ease-in-out 0.5s;
					}
					#principal:hover{
					-moz-transform: rotate(5deg);
					-webkit-transform: rotate(5deg);
					}
				</code>
			</pre>
		</p>
		<figure><b>Listado 3-26. </b>Una hermosa rotación usando transiciones.</figure>
		<p>
			Como puede ver en el Listado 3-26, la propiedad transition puede tomar hasta
			cuatro parámetros separados por un espacio. El primer valor es la propiedad que será
			considerada para hacer la transición (en nuestro ejemplo elegimos transform). Esto es
			necesario debido a que varias propiedades pueden cambiar al mismo tiempo y
			probablemente necesitemos crear los pasos del proceso de transición solo para una de
			ellas. El segundo parámetro especifica el tiempo que la transición se tomará para ir de la
			posición inicial a la final. El tercer parámetro puede ser cualquiera de las siguientes
			palabras clave: ease, linear, ease-in, ease-out o ease-in-out. Estas palabras clave
			determinan cómo se realizará el proceso de transición basado en una curva Bézier. Cada
			una de ellas representa diferentes tipos de curva Bézier, y la mejor forma de saber cómo
			trabajan es viéndolas funcionar en pantalla. El último parámetro para la propiedad
			transition es el retardo. Éste indica cuánto tiempo tardará la transición en comenzar. <br><br>

			Para producir una transición para todas las propiedades que están cambiando en un
			objeto, la palabra clave all debe ser especificada. También podemos declarar varias
			propiedades a la vez listándolas separadas por coma. <br><br>

			<ul>
				<b>Hágalo usted mismo: </b>Reemplace el correspondiente código del Listado 3-11 por
			el código del Listado 3-26 para probar el efecto en su navegador. <br><br>

				<b>IMPORTANTE: </b>En el Listado 3-26 realizamos una transición con la propiedad
			transform. No todas las propiedades CSS son soportadas por la propiedad
			transition en este momento y probablemente la lista cambie con el tiempo.
			Deberá probar cada una de ellas por usted mismo o visitar el sitio web oficial de
			cada navegador para encontrar más información al respecto.
			</ul>
		</p>
	</article><hr><br><br>


<!-- Referencias la segunda parte del capitulo 2-->


	<article id="52">
		<h2>Referencia rápida</h2>
		<p>
			CSS3 provee nuevas propiedades para crear efectos visuales y dinámicos que son parte
			esencial de la web en estos días. <br><br>

			<ul>
				<li><b>border-radius</b>Esta propiedad genera esquinas redondeadas para la caja formada por el
				elemento. Posee dos parámetros diferentes que dan forma a la esquina. El primer
				parámetro determina la curvatura horizontal y el segundo la vertical, otorgando la
				posibilidad de crear una elipsis. Para declarar ambos parámetros de la curva, los
				valores deben ser separados por una barra (por ejemplo, border-radius: 15px /
				20px). Usando solo un valor determinaremos la misma forma para todas las esquinas
				(por ejemplo, border-radius: 20px). Un valor para cada esquina puede ser
				declarado en un orden que sigue las agujas del reloj, comenzando por la esquina
				superior izquierda.</li><br>

				<li><b>box-shadow</b>Esta propiedad crea sombras para la caja formada por el elemento. Puede
				tomar cinco parámetros: el color, el desplazamiento horizontal, el desplazamiento
				vertical, el valor de difuminación, y la palabra clave inset para generar una sombra
				interna. Los desplazamientos pueden ser negativos, y el valor de difuminación y el valor
				inset son opcionales (por ejemplo, box-shadow: #000000 5px 5px 10px inset).</li><br>

				<li><b>text-shadow</b>sta propiedad es similar a box-shadow pero específica para textos. Toma
				cuatro parámetros: el color, el desplazamiento horizontal, el desplazamiento vertical, y
				el valor de difuminación (por ejemplo, text-shadow: #000000 5px 5px 10px).</li><br>

				<li><b>@font-face</b>Esta regla nos permite cargar y usar cualquier fuente que necesitemos.
				Primero, debemos declarar la fuente, proveer un nombre con la propiedad font-
				family y especificar el archivo con src (por ejemplo, @font-face{ font-family:Mifuente; src: url('font.ttf') }). Luego de esto, podremos asignar la fuente
				(en el ejemplo Mifuente) a cualquier elemento del documento.</li><br>

				<li><b>inear-gradient(posición inicio, color inicial, color final)</b>Esta función puede ser aplicada a
				las propiedades background o background-image para generar un gradiente lineal.
				Los atributos indican el punto inicial y los colores usados para crear el gradiente. El
				primer valor puede ser especificado en pixeles, en porcentaje o usando las palabras
				clave top, bottom, left y right. El punto de inicio puede ser reemplazado por un
				ángulo para proveer una dirección específica para el gradiente (por ejemplo, linear-
				gradient(top, #FFFFFF 50%, #006699 90%);).</li><br>

				<li><b>radial-gradient(posición inicio, forma, color inicial, color final)</b>Esta función puede ser
				aplicada a las propiedades background o background-image para generar un
				gradiente radial. La posición de inicio es el origen y puede ser declarado en pixeles,
				porcentaje o como una combinación de las palabras clave center, top, bottom, left
				y right. Existen dos valores para la forma: circle y ellipse, y puntos de
				terminación pueden ser declarados para cada color indicando la posición donde la
				transición comienza (por ejemplo, radial-gradient(center, circle, #FFFFFF
				0%, #006699 200%);).</li><br>

				<li><b>rgba()</b>Esta función es una mejora de rgb(). Toma cuatro valores: el color rojo (0-255), el
				color verde (0-255), el color azul (0-255), y la opacidad (un valor entre 0 y 1).</li><br>

				<li><b>hsla()</b>entre 0 y 360), la saturación (un porcentaje), la luminosidad (un porcentaje), y la
				opacidad (un valor entre 0 y 1)</li><br>

				<li><b>outline</b>outline-offset. Ambas propiedades combinadas generan un segundo borde
				alejado del borde original del elemento (por ejemplo, outline: 1px solid
				#000000; outline-offset: 10px;).</li><br>

				<li><b>border-image</b>el borde sea declarado previamente con las propiedades border o border-with, y
				toma al menos tres parámetros: la URL de la imagen, el tamaño de las piezas que serán
				tomadas de la imagen para construir el borde, y una palabra clave que especifica cómo
				esas piezas serán ubicadas alrededor del elemento (por ejemplo, border-image:
				url("file.png") 15 stretch;).</li><br>

				<li><b>ransform</b>Esta propiedad modifica la forma de un elemento. Utiliza cuatro funciones
				básicas: scale (escalar), rotate (rotar), skew (inclinar), y translate (trasladar o
				mover). La función scale recibe solo un parámetro. Un valor negativo invierte el
				elemento, valores entre 0 y 1 reducen el elemento y valores mayores que 1 expanden
				el elemento (por ejemplo, transform: scale(1.5);). La función rotate usa solo
				un parámetro expresado en grados para rotar el elemento (por ejemplo, transform:
				rotate(20deg);). La función skew recibe dos valores, también en grados, para la
				transformación horizontal y vertical (por ejemplo, transform: skew(20deg,
				20deg);). La función translate mueve el objeto tantos pixeles como sean
				especificados por sus parámetros (por ejemplo, transform: translate(20px);).</li><br>

				<li><b>transition</b>Esta propiedad puede ser aplicada para crear una transición entre dos estados
				de un elemento. Recibe hasta cuatro parámetros: la propiedad afectada, el tiempo que
				le tomará a la transición desde el comienzo hasta el final, una palabra clave para
				especificar cómo la transición será realizada (ease, linear, ease-in, ease-out,
				ease-in-out) y un valor de retardo que determina el tiempo que la transición
				tardará en comenzar (por ejemplo, transition: color 2s linear 1s;).</li><br>
			</ul>
		</p>
	</article><hr><br><br>


	<article>
		<h2>Proximamente Curso de Javascript.</h2>
	</article><hr><br><br>
	<div class="botom-de-subir">
		<a href="curso de css.html#0"class="botom-de-subir">☝🏻</a>

	</div>

	<footer class="pie">
		Derechos Reservados &copy; 2022.
	</footer>
</body>
</html>
